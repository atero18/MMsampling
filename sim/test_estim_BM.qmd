```{r}
library(dplyr)
options(dplyr.summarise.inform = FALSE)
library(tidyr)
library(glue)
library(tibble)
library(parallel)
library(tictoc)
library(ggplot2)
```

```{r}
devtools::load_all()
```

# Linear models on both modes

## Building constants

```{r}
set.seed(145L)
```

```{r}
N <- 10000L
phi <- rep(0.5, N)
```

Creating independent covariates

```{r}
p <- 1L

sex <- sample(c(0L, 1L), replace = TRUE, size = N, prob = c(0.5, 0.5))
age <- rnorm(n = N, mean = sex * 41.1 + (1L - sex) * 43.9, sd = 10.0)
age[age < 0.0] <- 0.0

Z <- data.frame(const = 1.0, 
                age = age, 
                sex = sex)

rm(age)
sex <- factor(sex)
levels(sex) <- c("Woman", "Man")
```

```{r}
summary(Z)
```

```{r}
data <- Z[, c("sex", "age")]
data$sex <- sex
ggplot(data) + 
  geom_density(aes(x = age, colour = sex)) +
  ggtitle("Age ~ sex")
rm(data)
```

```{r}
Z <- as.matrix(Z)
```

Creating parameters for two modes : "int" and "tel"

```{r}
betaInt <- c(4.5, 1.5, 8.0)
betaTel <- c(3.5, -1.0, 16.0)
```

We simulate a mode selection MAR (Missing At Random) under a logistic model, with $Z$ as variable:

```{r}
# With MAR

expit <- function(x) 1.0 / (1.0 + exp(-x))

alphaInt <- c(0.7, -0.02, -0.5)
pInt <- expit(Z %*% alphaInt) %>% as.vector()

alphaTel <- c(0.3, 0.02, -0.5)
pTel <- expit(Z %*% alphaTel) %>% as.vector()
```

Here are some details about the $p_{int}$ and $p_{tel}$:

```{r}
data.frame(mode = factor(rep(c("int", "tel"), each = N)), 
           prob = c(pInt, pTel)) %>% 
  ggplot() + 
  geom_density(aes(x = prob, color = mode)) +
  ggtitle("Distribution of p_int and p_tel")
```

```{r}
pInt[sex == "Man"] %>% summary()
pInt[sex == "Woman"] %>% summary()
```

```{r}
cat("internet probabilities:\n")
summary(pInt) %>% print()
cat("telephone probabilities:\n")
summary(pTel) %>% print()
```

## Simulation functions

Randomly affect a mode (or non-response) to each unit

```{r}
gen_choice_bimode <- function(I, p1, p2, mode1 = "int", mode2 = "tel")
{
  N <- length(p1)
  
  R1 <- runif(N) <= p1
  R2 <- runif(N) <= p2
  
  modes <- rep("nr", N)
  modes[R1] <- mode1
  
  modes[!R1 & R2] <- mode2
  
  modes[!I] <- "nr"
  
  modes
}
```

Parameters:

-   the constance of the bias, up to a Gaussian noise (`constBias`)
-   the sampling type (`sampling`)
-   the law of $Y_{tel}$ (`YtelLaw`)
-   the law of $\Delta y$ (`deltaLaw`)
-   the state of $\phi$ (`phi`)

```{r}
#| echo: false

simulation1 <- function(constBias = FALSE,
                        sampling = "SRS",
                        YtelLaw = "gaussian", 
                        deltaLaw = "gaussian",
                        phiType = "eq",
                        addFalseEstimators = FALSE,
                        ...)
{
  if (phiType == "eq")
    phi <- rep(0.5, N)
  
  else if (phiType == "var")
    phi <- seq_len(N) / N
  
  # Handling sampling
 
  n <- ceiling(N / 4L)
  
  
  if (sampling == "SRS")
  {
    selectedSample <- sample(seq_len(N), size = n, replace = FALSE)
    pi <- rep(n / N, N)
    I <- rep(FALSE, N)
    I[selectedSample] <- TRUE
    rm(selectedSample)
  }
  
  else if (sampling == "STSRS")
  {
    nbMen <- sum(sex == "Man")
    selectedSampleMen <- sample(which(sex == "Man"),
                                size = ceiling(2L * nbMen / 3L),
                                replace = FALSE)

    nbWomen <- sum(sex == "Woman")
    selectedSampleWomen <- sample(which(sex == "Woman"),
                                  size = ceiling(nbWomen / 3L),
                                  replace = FALSE)
    I <- rep(FALSE, N)
    I[selectedSampleMen] <- TRUE
    I[selectedSampleWomen] <- TRUE
    rm(selectedSampleMen)
    rm(selectedSampleWomen)
    pi <- rep(1.0 / 3.0, N)
    pi[sex == "Man"] <- 2.0 / 3.0
  }
  
  
  
  # Mode selection simulation
  modes <- gen_choice_bimode(I, pInt, pTel)
  trueProbsSelect <- rep(NA_real_, N)
  trueProbsSelect[modes == "int"] <- pInt[modes == "int"]
  trueProbsSelect[modes == "tel"] <- ((1.0 - pInt) * pTel)[modes == "tel"]
  
  
  trueWeights <- (pi * trueProbsSelect)^-1L
  
  # Affecting values to Y_int and Y_tel
  if (YtelLaw == "gaussian")
  {
    Ytel <- Z %*% betaTel + rnorm(n = N, sd = 25.0)
    expectedTotalYtel <- sum(Z %*% betaTel)
  }
  else if (YtelLaw == "exponential")
  {
    Ytel <- rexp(n = N, rate = abs(Z %*% betaTel)^-1L)
    expectedTotalYtel <- sum(abs(Z %*% betaTel))
  }
    
  
  trueTotalYtel <- sum(Ytel)
  

  if (deltaLaw == "gaussian")
  {
    # Case when the measure bias is constant, up to a white noise
    if (constBias)
      deltas <- rnorm(N, betaInt[1L] - betaTel[1L], 25.0)
    
    # Case when the measure bias is dependant of the covariates
    else
      deltas <- Z %*% (betaInt - betaTel) + rnorm(N, 0.0, 25.0)
  }
  else if (deltaLaw == "exponential")
  {
    if (constBias)
      deltas <- rexp(n = N, rate = abs(betaInt[1L] - betaTel[1L])^-1L)
    
    else
      deltas <- rexp(n = N, rate = abs(Z %*% (betaInt - betaTel))^-1L)
  }
  else
    deltas <- seq_len(N)
  
  Yint <- Ytel + deltas
  

  # Evaluating the measure bias total (random value)
  trueTotalBias <- sum(phi * deltas)
  
  if (constBias)
    expectedPhiBias <- sum(phi) * (betaInt[1L] - betaTel[1L])
  else
    expectedPhiBias <- t(phi) %*% Z %*% (betaInt - betaTel)
  
  
  # Creating the observed outcome vector
  Yobs <- rep(NA_real_, N)
  Yobs[modes == "int"] <- Yint[modes == "int"]
  Yobs[modes == "tel"] <- Ytel[modes == "tel"]
  
  sample <- MMSample$new(Z = Z, pi = pi, I = I, 
                         modes = modes, Yobs = Yobs, phi = phi)
  
  results <- data.frame(estimator = character(),
                        trueEstimator = logical(),
                        probSelect = character(),
                        invMatrix = character(),
                        estTotPhiBias = numeric())
  
  # Calculate false estimators with true mode selection probabilities
  if (addFalseEstimators)
  {
    # Full HT estimation, with full population matrix (Z^tZ)^-1 and
    # known probabilities
    resEval <-
      estim_delta_MCO(sample$Z, sample$Yobs, sample$modes,
                             "int", "tel", "HT", "HT", pi,
                      trueProbsSelect, sampleMatrix = FALSE) %>%
      estim_MB_by_MCO(Z, phi = phi) %>%
      sum()

    results <- results %>%
      add_row(estimator = "HT", trueEstimator = FALSE,
              probSelect = "true", invMatrix = "true", estTotPhiBias = resEval)

    # Full HT estimation, with sample matrix (Z_S^TZ_S)^-1 and
    # known probabilities
    resEval <-
      estim_delta_MCO(sample$Z, sample$Yobs, sample$modes,
                             "int", "tel", "HT", "HT", pi,
                      trueProbsSelect, sampleMatrix = TRUE) %>%
      estim_MB_by_MCO(Z, phi = phi) %>%
      sum()

    results <- results %>%
      add_row(estimator = "HT", trueEstimator = FALSE,
              probSelect = "true", invMatrix = "sample", estTotPhiBias = resEval)
  }
  
  
  
  # G-COMP estimation, <=> double MCO estimation
  # tic()
  resEval <- 
    estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                    "int", "tel", "MCO", "MCO", pi, NULL) %>% 
    estim_MB_by_MCO(Z, phi = phi) %>% 
    sum()
  # toc() %>% print()
  
  
  results <- results %>% 
    add_row(estimator = "G-COMP", trueEstimator = TRUE,
            probSelect = "null", 
            invMatrix = "null", estTotPhiBias = resEval)
  
  
  # Estimation on a unique MCO for Y1 and Y2, with beta X and only a constant
  # delta for the estimation of the measure bias
  deltaEval <- estim_delta_MCO_unique_model_const(Z, Yobs, modes, "int", "tel")
  resEval <- sum(phi) * deltaEval
  
  results <- results %>% 
    add_row(estimator = "MCO_unique", trueEstimator = TRUE,
            probSelect = "null", 
            invMatrix = "null", estTotPhiBias = resEval)
  
  
  # Value estimated only on telephone answers, with true selection probabilities
  resEval <- sum(trueWeights[modes == "tel"] * Ytel[modes == "tel"])
  
  results <- results %>% 
    add_row(estimator = "HT_Smr", trueEstimator = FALSE,
            probSelect = "null", invMatrix = "null", estTotPhiBias = resEval)
  
  browser()
  
  # Estimation of mode selection probabilities
  tempProbsSelect <- 
    estim_response_prob_sequential(I, Z, modes, c("int", "tel"))$unconditional
  

  
  estimWeights <- (pi * tempProbsSelect)^-1L
  
    # Full HT estimation, with full population matrix (Z^tZ)^-1 and
  # unknown probabilities
  # tic()
  resEval <- 
    estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                         "int", "tel", "HT", "HT", pi, 
                    tempProbsSelect, sampleMatrix = FALSE) %>% 
  estim_MB_by_MCO(Z, phi = phi) %>% 
  sum()
  # toc() %>% print()
 
  
  results <- results %>% 
    add_row(estimator = "HT", trueEstimator = TRUE,
            probSelect = "estimation", invMatrix = "true", estTotPhiBias = resEval)
 
  # Full HT estimation, with sample matrix (Z_S^TZ_S)^-1 and
  # unknown probabilities
  # tic()
  resEval <- 
    estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                         "int", "tel", "HT", "HT", pi, 
                    tempProbsSelect, sampleMatrix = TRUE) %>% 
  estim_MB_by_MCO(Z, phi = phi) %>% 
  sum()
  # toc() %>% print()
  
  results <- results %>% 
    add_row(estimator = "HT", trueEstimator = TRUE,
            probSelect = "estimation", invMatrix = "sample", estTotPhiBias = resEval)
  
  # Value estimated only on telephone answers, with estimated selection probabilities
  resEval <- sum(estimWeights[modes == "tel"] * Ytel[modes == "tel"])
  
  results <- results %>% 
    add_row(estimator = "HT_Smr", trueEstimator = FALSE,
            probSelect = "null", invMatrix = "null", estTotPhiBias = resEval)
  
  estTotalPhiYintHTTrueMP <- 
    phi[modes == "int"] * 
    trueWeights[modes == "int"] * 
    Yint[modes == "int"]
  
  estTotalPhiYintHTTrueMP <- sum(estTotalPhiYintHTTrueMP)
  
  estTotalPhiYtelHTTrueMP <- 
    (1.0 - phi[modes == "tel"]) * 
    trueWeights[modes == "tel"] * 
    Ytel[modes == "tel"]
  
  estTotalPhiYtelHTTrueMP <- sum(estTotalPhiYtelHTTrueMP)
  
  
  

  estTotalPhiYintHTEstMP <-
    phi[modes == "int"] *
    estimWeights[modes == "int"] *
    Yint[modes == "int"]

  estTotalPhiYintHTEstMP <- sum(estTotalPhiYintHTEstMP)

  estTotalPhiYtelHTEstmMP <-
    (1.0 - phi[modes == "tel"]) *
    estimWeights[modes == "tel"] *
    Ytel[modes == "tel"]

  estTotalPhiYtelHTEstmMP <- sum(estTotalPhiYtelHTEstmMP)
  
  
  
  results <- results %>% 
    add_column(.before = 1L, trueTotalYtel = trueTotalYtel) %>% 
    add_column(.after = "trueTotalYtel", expectedTotalYtel = expectedTotalYtel) %>% 
    add_column(.before = "estTotPhiBias", truePhiBias = trueTotalBias) %>% 
    add_column(.after = "truePhiBias", expectedPhiBias = expectedPhiBias) %>% 
    add_column(.after = "expectedPhiBias", estTotalPhiYintTrueMP = estTotalPhiYintHTTrueMP) %>% 
    add_column(.after = "estTotalPhiYintTrueMP", estTotalPhiYintEstMP = estTotalPhiYintHTEstMP) %>% 
    add_column(.after = "estTotalPhiYintEstMP", estTotalPhiYtelTrueMP = estTotalPhiYtelHTTrueMP) %>% 
    add_column(.after = "estTotalPhiYtelTrueMP", estTotalPhiYtelEstMP = estTotalPhiYtelHTEstmMP) %>% 
    mutate(.after = "estTotalPhiYtelEstMP",
           estTotalYtelTrueMP = estTotalPhiYintTrueMP + estTotalPhiYtelTrueMP - estTotPhiBias) %>% 
    mutate(.after = "estTotalYtelTrueMP", 
           estTotalYtelEstMP = estTotalPhiYintEstMP + 
             estTotalPhiYtelEstMP -
             estTotPhiBias) %>% 
    add_column(.after = "estTotalYtelEstMP", sampling = sampling) %>% 
    add_column(.after = "sampling", YtelLaw = factor(YtelLaw)) %>% 
    add_column(.after = "YtelLaw", deltaLaw = factor(deltaLaw)) %>% 
    add_column(.after = "deltaLaw",
               MBtype = factor(ifelse(constBias, "constant", "variable"))) %>% 
    add_column(.after = "MBtype", phi = factor(phiType))
  
  results
}
```

-   `trueTotalYtel`: $t_{tel} =\sum_{k \in U} y_{2k}$ for this iteration
-   `expectedTotalYtel` : $\mathbb{E}[t_{tel}]=\mathbb{E} [\sum_{k \in U} y_{2k}]$
-   `estTotPhiBias` : $t_{\phi \hat{\Delta y}}$
-   `truePhiBias` : $t_{\phi\Delta y}=\sum_{k\in U} \phi_k \Delta y_k$
-   `expectedPhiBias` : $\mathbb{E}[t_{\phi\Delta y}]$
-   `estTotalPhiYintTrueMP` : $\hat{t}_{p,\phi y_1} = \sum_{k \in S_r}\frac{\phi_k y_{1k}}{\pi_k p_{1k}}$
-   `estTotalPhiYintEstMP` : $\hat{t}_{\hat{p},\phi y_1} = \sum_{k \in S_r}\frac{\phi_k y_{1k}}{\pi_k \hat{p}_{1k}}$
-   `estTotalPhiYintEstMP` : $\hat{t}_{\hat{p},\phi y_1} + \hat{t}_{\hat{p},\phi y_2} - t_{\phi \hat{\Delta y}}$

## Measure bias evaluation

Evaluation of $K$ experiments

```{r}
K <- 5L
```

```{r}
#| echo: false

set.seed(200L)

results <- NULL
nbResults <- 0L

parameters <- expand_grid(constBias = c(TRUE, FALSE), 
                          sampling = "SRS", #sampling = c("SRS", "STSRS"),
                          YtelLaw = "gaussian", #c("gaussian", "exponential"),
                          deltaLaw = "gaussian", #c("gaussian", "exponential"),
                          phi = "eq")#c("eq", "var"))

tic()
for (i in seq_len(nrow(parameters)))
{
  expParams <- parameters[i, ]
  #print(expParams)

  expResults <- lapply(seq_len(K), simulation1, 
                       sampling = expParams$sampling,
                       constBias = expParams$constBias,
                       YtelLaw = expParams$YtelLaw,
                       deltaLaw = expParams$deltaLaw,
                       phi = expParams$phi)
  
  expResults <- do.call("rbind", expResults)
  
  
  if (i == 1L)
    expNbResults <- nrow(expResults)
  
  nbresults <- nbResults + expNbResults
  expResults <- expResults %>% 
    add_column(.before = 1L, 
               experiment = factor(rep(nbResults + seq_len(K), 
                                       each = expNbResults / K)))
  
  results <- rbind(results, expResults)
}
toc()

results$estimator <- as.factor(results$estimator)
results$probSelect <- as.factor(results$probSelect)
results$invMatrix <- as.factor(results$invMatrix)
results <- results %>% 
  mutate(.after = "estTotPhiBias", diffPhiBias = estTotPhiBias - truePhiBias) %>% 
  mutate(.after = "estTotalPhiYtelEstMP", 
         diffTotalYtelEstMP = estTotalYtelEstMP - trueTotalYtel) %>% 
  mutate(.after = "estTotalPhiYtelTrueMP",
         diffTotalYtelTrueMP = estTotalYtelTrueMP - trueTotalYtel)
```

## Ex : Gaussian constant measure bias

Results of each estimator for the case of SRS with **constant** measure bias and Gaussian laws

### Measure bias total

$$\text{reldiffMean} = \frac{1}{K}\sum_{k=1}^K \frac{\hat{t}_{\phi\Delta y,k}-t_{\phi\Delta y,k}}{\mathbb{E}[t_{\phi\Delta y}]}$$

$$\text{relRMSE} = \frac{\sqrt{\frac{1}{K}\sum_{k=1}^K (\hat{t}_{\phi\Delta y,k}-t_{\phi\Delta y,k})^2}}{|\mathbb{E}[t_{\phi\Delta y}]|}$$

```{r}
results %>% 
  filter(YtelLaw == "gaussian", deltaLaw == "gaussian", 
         sampling == "SRS", MBtype == "constant",
         probSelect != "true") %>% 
  select(-sampling, -MBtype) %>% 
  group_by(phi, estimator, probSelect, invMatrix) %>% 
  summarise(reldiffMean = round(mean(diffPhiBias / abs(expectedPhiBias)) , 4L), 
            relRMSE = round(sqrt(mean(diffPhiBias^2L / expectedPhiBias^2L)), 4L)) %>% 
  ungroup() %>% 
  arrange(relRMSE)
```

### telephone total estimation

```{r}
results %>% 
  filter(YtelLaw == "gaussian", deltaLaw == "gaussian", 
         sampling == "SRS", MBtype == "constant",
         probSelect != "true") %>% 
  select(-sampling, -MBtype) %>% 
  group_by(phi, estimator, probSelect, invMatrix) %>% 
  summarise(reldiffTotalTrueMean = round(mean(diffTotalYtelTrueMP / abs(expectedTotalYtel)) , 4L), 
            reldiffTotalEstMean = round(mean(diffTotalYtelEstMP / abs(expectedTotalYtel)) , 4L),
            relRMSETrue = round(sqrt(mean(diffTotalYtelTrueMP^2L / expectedTotalYtel^2L)), 4L),
            relRMSEEst = round(sqrt(mean(diffTotalYtelEstMP^2L / expectedTotalYtel^2L)), 4L)) %>% 
  ungroup() %>% 
  arrange(relRMSEEst)
```

Differences between G-COMP and HT with sample inverse matrix results in that case (with constant phi):

```{r}
results %>% 
  filter(YtelLaw == "gaussian", deltaLaw == "gaussian", 
         sampling == "SRS", MBtype == "constant",
         phi == "eq",  trueEstimator, estimator == "G-COMP" | (estimator == "HT" & invMatrix == "sample")) %>% 
  select(experiment, estimator, invMatrix, diff) %>% 
  head(n = 8L) %>% 
  group_by(experiment)
```

## Ex : Gaussian variable measure bias

Results of each estimator for the case of SRS with **variable** measure bias and Gaussian laws

```{r}
results %>% 
  filter(YtelLaw == "gaussian", deltaLaw == "gaussian", 
         sampling == "SRS", MBtype == "variable",
         phi == "eq", trueEstimator) %>% 
  select(-sampling, -MBtype, -phi) %>% 
  group_by(estimator, probSelect, invMatrix) %>% 
  summarise(reldiffMean = round(mean(diff / abs(expectedPhiBias)) , 4L), 
            relRMSE = round(sqrt(mean(diff^2L / expectedPhiBias^2L)), 4L)) %>% 
  ungroup() %>% 
  arrange(relRMSE)
```

Optimal RMSE for each condition:

```{r}
results %>% 
  filter(probSelect != "true") %>% 
  group_by(MBtype, sampling, YtelLaw, deltaLaw, phi, estimator, probSelect, invMatrix) %>% 
  summarise(reldiffMean = round(mean(diff / abs(expectedPhiBias)) , 4L), 
            relRMSE = round(sqrt(mean(diff^2L / expectedPhiBias^2L)), 4L)) %>% 
  ungroup() %>% 
  group_by(MBtype, YtelLaw, deltaLaw, sampling, phi) %>% 
  slice_min(relRMSE) # %>% 
  # knitr::kable()
```
