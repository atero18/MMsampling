```{r}
library(dplyr)
options(dplyr.summarise.inform = FALSE)
library(tidyr)
library(glue)
library(tibble)
library(parallel)
library(tictoc)
library(ggplot2)
library(Matrix)
```

```{r}
devtools::load_all()
```

# Linear models on both modes

## Building constants

```{r}
set.seed(145L)
```

```{r}
N <- 1000L
phi <- rep(0.5, N)
```

Creating independent covariates

```{r}
p <- 1L

sex <- sample(c(0L, 1L), replace = TRUE, size = N, prob = c(0.5, 0.5))
age <- rnorm(n = N, mean = sex * 41.1 + (1L - sex) * 43.9, sd = 10.0)
age[age < 0.0] <- 0.0

Z <- data.frame(const = 1.0, 
                age = age, 
                sex = sex)

rm(age)
sex <- factor(sex)
levels(sex) <- c("Woman", "Man")
```

```{r}
summary(Z)
```

```{r}
data <- Z[, c("sex", "age")]
data$sex <- sex
ggplot(data) + 
  geom_density(aes(x = age, colour = sex)) +
  ggtitle("Age ~ sex")
rm(data)
```

```{r}
Z <- as.matrix(Z)
```

Creating parameters for two modes : "int" and "tel". `delta` is defined such that the average measure bias is equal to 1. It depends on `Z`.

```{r}
betaTel <- c(7.0, -0.1, 4.0)
print(betaTel)
delta <- c(1.0, -2.0 * mean(Z[, "age"])^-1L, 2.0 * N / sum(Z[, "sex"]))
betaInt <- betaTel + delta
  

print(betaInt)
```

$Y_{int}$ and $Y_{tel}$ expectations depending on `Z`:

```{r}
data.frame(tel = Z %*% betaTel, int = Z %*% betaInt) %>% 
  pivot_longer(cols = c("tel", "int"), names_to = "mode", values_to = "value") %>% 
  ggplot() + geom_density(aes(x = value, colour = mode))

glue("average value for telephone: {mean(Z %*% betaTel)}")
glue("average value for internet: {mean(Z %*% betaInt)}")
```


```{r}
totBias <- sum(Z %*% delta)
glue("total bias on U: {totBias}")
meanBias <- totBias / N
glue("average bias on U: {meanBias}")
```

We simulate a mode selection MAR (Missing At Random) under a logistic model, with $Z$ as variable:

```{r}
# With MAR

expit <- function(x) 1.0 / (1.0 + exp(-x))

alphaInt <- c(0.7, -0.02, -0.5)
pInt <- expit(Z %*% alphaInt) %>% as.vector()

alphaTel <- c(0.3, 0.02, -0.5)
pTel <- expit(Z %*% alphaTel) %>% as.vector()
```

Here are some details about the $p_{int}$ and $p_{tel}$:

```{r}
data.frame(mode = factor(rep(c("int", "tel"), each = N)), 
           prob = c(pInt, pTel)) %>% 
  ggplot() + 
  geom_density(aes(x = prob, color = mode)) +
  ggtitle("Distribution of p_int and p_tel")
```

```{r}
pInt[sex == "Man"] %>% summary()
pInt[sex == "Woman"] %>% summary()
```

```{r}
cat("internet probabilities:\n")
summary(pInt) %>% print()
cat("telephone probabilities:\n")
summary(pTel) %>% print()
```

## Simulation functions

Randomly affect a mode (or non-response) to each unit

```{r}
gen_choice_bimode <- function(I, p1, p2, mode1 = "int", mode2 = "tel")
{
  N <- length(p1)
  
  R1 <- runif(N) <= p1
  R2 <- runif(N) <= p2
  
  modes <- rep("nr", N)
  modes[R1] <- mode1
  
  modes[!R1 & R2] <- mode2
  
  modes[!I] <- "nr"
  
  modes
}
```

```{r}
simulationUncounf <- 
  function(N,
           meanZ = numeric(length(alphaInt)), 
           covarZ = diag(1.0, length(alphaInt)), 
           fixZ = TRUE,
           sampling = "SRS",
           alphaInt, alphaTel, 
           betaInt, betaTel, 
           YintLaw = "gaussian", YtelLaw = "gaussian",
           sdInt = 1.0, sdTel = 1.0, 
           phi = rep(0.5, N), K = 1000L,
           Z = NULL,
           n = ceiling(N / 4L),
           seed = 123L)
  {
    
    nbCores <- detectCores() - 1L
    cluster <- makeCluster(nbCores)
    
    # Making clusters random-independants
    clusterSetRNGStream(cl = cluster, iseed = seed)
    
    clusterEvalQ(cluster, library(dplyr))
    clusterEvalQ(cluster, library(Matrix))
    clusterEvalQ(cluster, library(tibble))
    clusterEvalQ(cluster, library(MMsampling))
    
    clusterExport(cluster, varlist = c("sampling", 
                                       "betaInt", "betaTel", 
                                       "YintLaw", "YtelLaw", 
                                       "sdInt", "sdTel", 
                                       "n"),
                  envir = environment())
    
    expit <- function(x) 1.0 / (1.0 + exp(-x))

    if (!is.null(Z))
    {
      fixZ <- TRUE
      clusterExport(cluster, 
                    varlist = "Z",
                    envir = environment())
      
    }
    else if (fixZ)
    {
      Z <- mvtnorm::rmvnorm(N, mean = meanZ, sigma = covarZ, checkSymmetry = TRUE)
      clusterExport(cluster,
                    varlist = "Z",
                    envir = environment())
    }
      
    clusterExport(cluster, 
                  varlist = "fixZ",
                  envir = environment())
    
    if (fixZ)
    {
      pInt <- expit(Z %*% alphaInt) %>% as.numeric()
      pq1Mat <- pInt %*% t(pInt)
      diag(pq1Mat) <- pInt
      
      pTel <- expit(Z %*% alphaTel) %>% as.numeric()
      pq2Mat <- pTel %*% t(pTel)
      diag(pq2Mat) <- pTel
      
      clusterExport(cluster, 
                    varlist = c("pInt", "pq1Mat", "pTel", "pq2Mat"),
                    envir = environment())
    }
    else
    {
      clusterExport(cluster, 
                    varlist = c("meanZ", "covarZ",
                                "alphaInt", "alphaTel", 
                                "expit"),
                    envir = environment())
    }
    
    if (fixZ)
    {
      if (sampling == "SRS")
      {
        pi <- rep(n / N, N)
        piMat <- matrix(n * (n - 1L) / (N * (N - 1L)), nrow = N, ncol = N)
        diag(piMat) <- n / N
        
        clusterExport(cluster, 
                      varlist = c("pi", "piMat"),
                      envir = environment())
      }
    }
    
    if (fixZ)
    {
      if (YtelLaw == "gaussian")
      {
        expYtel <- as.vector(Z %*% betaTel)
        covarYTel <- diag(sdTel^2L, N)
      }
      else if (YtelLaw == "exponential")
      {
        expYtel <- as.vector(abs(Z %*% betaTel))
        covarYTel <- diag(expYtel^2L)
      }
      
      if (YintLaw == "gaussian")
      {
        expYint <- as.vector(Z %*% betaInt)
        covarYint <- diag(sdInt^2L, N)
      }
      else if (YintLaw == "exponential")
      {
        expYint <- as.vector(abs(Z %*% betaInt))
        covarYint <- diag(expYint^2L)
      }
      
      clusterExport(cluster,
                    varlist = c("expYtel", "covarYTel", 
                                "expYint", "covarYint"),
                    envir = environment())
    }
    
    clusterExport(cluster, "gen_choice_bimode")
      
    
    if (class(phi) == "character")
      phiType <- phi
    else
      phiType <- "vector"
    
    if (phi == "eq")
      phi <- rep(0.5, N)
  
    else if (phi == "var")
      phi <- seq_len(N) / N
    
    else if (phi == "bestProb")
      phi <- ifelse(pInt >= 0.5, 1.0, 0.0)
    
    clusterExport(cluster, 
                  varlist = "phi", 
                  envir = environment())
    
    monoSim <- function(...)
    {
      nbExperiments <- 10L
      
      partialResults <- data.frame(parameter = character(nbExperiments),
                                   trueParameter = logical(nbExperiments),
                                   probSelect = character(nbExperiments),
                                   invMatrix = character(nbExperiments),
                                   calculTotal = character(nbExperiments),
                                   estTotPhiBias = numeric(nbExperiments))
      
      row <- 1L
      
      if (!fixZ)
      {
        Z <- mvtnorm::rmvnorm(N, mean = meanZ, sigma = covarZ, checkSymmetry = TRUE)
        
        
        pInt <- expit(Z %*% alphaInt)
        pq1Mat <- pInt %*% pInt
        diag(pq1Mat) <- pInt
        
        pTel <- expit(Z %*% alphaTel)
        pq2Mat <- pTel %*% pTel
        diag(pq1Mat) <- pTel
      }
      
      p <- ncol(Z)
        
      
      if (sampling == "SRS")
      {
        if (!fixZ)
        {
          pi <- rep(n / N, N)
          piMat <- matrix(n * (n - 1L) / (N * (N - 1L)), nrow = N, ncol = N)
          diag(piMat) <- n / N
        }
        
        
        selectedSample <- sample(seq_len(N), size = n, replace = FALSE)
        
        I <- logical(N)
        I[selectedSample] <- TRUE
        rm(selectedSample)
      }
      
      # Mode selection simulation
      modeChoiceOK <- FALSE
      
      while (!modeChoiceOK)
      {
        # modeChoiceOK <- TRUE
        
        modes <- gen_choice_bimode(I, pInt, pTel)
        trueProbsSelect <- rep(NA_real_, N)
        maskInt <- modes == "int"
        maskTel <- modes == "tel"
        trueProbsSelect[maskInt] <- pInt[maskInt]
        trueProbsSelect[maskTel] <- ((1.0 - pInt) * pTel)[maskTel]
        
        if (rankMatrix(Z[maskInt, , drop = FALSE]) == p && rankMatrix(Z[maskTel, , drop = FALSE]) == p)
          modeChoiceOK <- TRUE
        else
          warning("Singular Zint / Ztel")
        
      }
      
      
      trueWeights <- (pi * trueProbsSelect)^-1L
    
      # Estimation of mode selection probabilities
      estimProbsSelect <- 
        MMsampling::estim_response_prob_sequential(I, Z,
                                                   modes, 
                                                   c("int", "tel"))$unconditional
    
      estimWeights <- (pi * estimProbsSelect)^-1L
      
      
       # Affecting values to Y_int and Y_tel
      if (YtelLaw == "gaussian")
      {
        if (!fixZ)
        {
          expYtel <- as.vector(Z %*% betaTel)
          covarYTel <- diag(sdTel^2L, N)
        }
        Ytel <- expYtel + rnorm(n = N, sd = sdTel)
        
      }
      else if (YtelLaw == "exponential")
      {
        if (!fixZ)
        {
          expYtel <- as.vector(abs(Z %*% betaTel))
          covarYTel <- diag(expYtel^2L)
        }
        Ytel <- rexp(n = N, rate = expYtel^-1L)
      }
      
      expTotalYtel <- sum(expYtel)
      trueTotalYtel <- sum(Ytel)
      
      if (YintLaw == "gaussian")
      {
        if (!fixZ)
        {
          expYint <- as.vector(Z %*% betaInt)
          covarYint <- diag(sdInt^2L, N)
        }
        Yint <- expYint + rnorm(n = N, sd = sdInt)
        
      }
      else if (YintLaw == "exponential")
      {
        if (!fixZ)
        {
          expYint <- as.vector(abs(Z %*% betaInt))
          covarYint <- diag(expYint^2L)
        }
        Yint <- rexp(n = N, rate = expYint^-1L)
      }
        
      deltas <- Yint - Ytel
      
    
      # Evaluating the measure bias total (random value)
      trueTotalBias <- crossprod(phi, deltas)
      expPhiBias <- crossprod(phi, expYint - expYtel)
      
      # Creating the observed outcome vector
      Yobs <- rep(NA_real_, N)
      Yobs[maskInt] <- Yint[maskInt]
      Yobs[maskTel] <- Ytel[maskTel]
      
      sample <- MMsampling:::MMSample$new(Z = Z, pi = pi, I = I, 
                             modes = modes, Yobs = Yobs, phi = phi)
      
      # Full HT estimation, with full population matrix (Z^tZ)^-1 and
      # known probabilities
      resEval <-
        estim_delta_MCO(sample$Z, sample$Yobs, sample$modes,
                               "int", "tel", "HT", "HT", pi,
                        trueProbsSelect, sampleMatrix = FALSE) %>%
        estim_MB_by_MCO(Z, phi = phi) %>%
        sum()
      
      ##browser()
      
      ##if (YintLaw == "gaussian" && YtelLaw == "exponential")
      ##  browser()
      
      # expSD <- var_estim_tot_BM(modeTotBiased = "HT", modeTotRef = "HT",
      #                           calculTotal = "full",
      #                           expY1 = expYint, expY2 = expYtel,
      #                           covarY1 = covarYint, 
      #                           covarY2 = covarYTel,
      #                           piMat = piMat,
      #                           pq1Mat = pq1Mat, pq2Mat = pq2Mat,
      #                           phi = phi)
      # 
      # expSD <- sqrt(expSD)
  
      partialResults[row,] <- 
        c(parameter = "HT", trueParameter = FALSE,
          probSelect = "true", invMatrix = "true",
          calculTotal = "full", estTotPhiBias = resEval)
      
      row <- row + 1L
  
      # Full HT estimation, with sample matrix (Z_S^TZ_S)^-1 and
      # known probabilities
      resEval <-
        estim_delta_MCO(sample$Z, sample$Yobs, sample$modes,
                               "int", "tel", "HT", "HT", pi,
                        trueProbsSelect, sampleMatrix = TRUE) %>%
        estim_MB_by_MCO(Z, phi = phi) %>%
        sum()
  
      partialResults[row,] <- c(parameter = "HT", trueParameter = FALSE,
                probSelect = "true", invMatrix = "sample", 
                calculTotal = "full", estTotPhiBias = resEval)
      
      row <- row + 1L
      
        # G-COMP estimation, <=> double MCO estimation
      # tic()
      estimdelta <- estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                        "int", "tel", "MCO", "MCO", pi, NULL)
      
      resEvalFull <- estimdelta %>% 
        estim_MB_by_MCO(Z, phi = phi) %>% 
        sum()
      
      resEvalHT <- estimdelta %>% 
        estim_MB_by_MCO(Z, phi = phi, weights = estimWeights, mask = maskInt) %>% 
        sum()
      # toc() %>% print()
      
      
      
      partialResults[c(row, row + 1L),] <- 
        data.frame(parameter = "G-COMP", trueParameter = TRUE,
          probSelect = "null", 
          invMatrix = "null", calculTotal = c("full", "partial"),
          estTotPhiBias = c(resEvalFull, resEvalHT))
      
      row <- row + 2L
      
      # Estimation on a unique MCO for Y1 and Y2, with beta X and only a constant
      # delta for the estimation of the measure bias
      deltaEval <- estim_delta_MCO_unique_model_const(Z, Yobs, modes, "int", "tel")
      resEvalFull <- sum(phi) * deltaEval
      resEvalHT <- crossprod(phi[maskInt], estimWeights[maskInt]) * deltaEval
      
      partialResults[c(row, row + 1L),] <- 
        data.frame(parameter = "MCO_unique",
                   trueParameter = TRUE,
                   probSelect = "null", calculTotal = c("full", "partial"),
                   invMatrix = "null", 
                   estTotPhiBias = c(resEvalFull, resEvalHT))
      
      
      row <- row + 2L
      
      # Full HT estimation, with full population matrix (Z^tZ)^-1 and
      # unknown probabilities
      # tic()
      estimdelta <- 
        estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                             "int", "tel", "HT", "HT", pi, 
                        estimProbsSelect, sampleMatrix = FALSE)
      
      resEvalFull <- estimdelta %>% 
        estim_MB_by_MCO(Z, phi = phi) %>% 
        sum()
      
      resEvalHT <- estimdelta %>% 
        estim_MB_by_MCO(Z, phi = phi, weights = estimWeights, mask = maskInt) %>% 
        sum()
    
      # toc() %>% print()
     
      
      partialResults[c(row, row + 1L),] <- 
        data.frame(parameter = "HT", trueParameter = TRUE,
                   probSelect = "estimation", invMatrix = "true", 
                   calculTotal = c("full", "partial"), 
                   estTotPhiBias = c(resEvalFull, resEvalHT))
      
      row <- row + 2L
      
      # Full HT estimation, with sample matrix (Z_S^TZ_S)^-1 and
      # unknown probabilities
      # tic()
      estimdelta <- 
        estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                             "int", "tel", "HT", "HT", pi, 
                        estimProbsSelect, sampleMatrix = TRUE) 
      
      
      resEvalFull <- estimdelta %>% 
        estim_MB_by_MCO(Z, phi = phi) %>% 
        sum()
      
      resEvalHT <- estimdelta %>% 
        estim_MB_by_MCO(Z, phi = phi, weights = estimWeights, mask = maskInt) %>% 
        sum()
    
      # toc() %>% print()
      
      partialResults[c(row, row + 1L),] <- 
        data.frame(parameter = "HT", trueParameter = TRUE,
                   probSelect = "estimation", invMatrix = "sample", 
                   calculTotal = c("full", "partial"), 
                   estTotPhiBias = c(resEvalFull, resEvalHT))
      
      row <- row + 2L
      
      # Estimations of t_phi1 and t_phi2
      # - With true weights
      estTotPhiYintHTTrueMP <- 
        phi[maskInt] * 
        trueWeights[maskInt] * 
        Yint[maskInt]
      
      estTotPhiYintHTTrueMP <- sum(estTotPhiYintHTTrueMP)
      
      estTotPhiYtelHTTrueMP <- 
        (1.0 - phi[maskTel]) * 
        trueWeights[maskTel] * 
        Ytel[maskTel]
      
      # - With estimated weights
      estTotPhiYtelHTTrueMP <- sum(estTotPhiYtelHTTrueMP)
    
      estTotPhiYintHTEstMP <-
        phi[maskInt] *
        estimWeights[maskInt] *
        Yint[maskInt]
    
      estTotPhiYintHTEstMP <- sum(estTotPhiYintHTEstMP)
    
      estTotPhiYtelHTEstmMP <-
        (1.0 - phi[maskTel]) *
        estimWeights[maskTel] *
        Ytel[maskTel]
    
      estTotPhiYtelHTEstmMP <- sum(estTotPhiYtelHTEstmMP)
      
      ## Don't know why but some columns are
      ##  automatically converted as character
      partialResults$estTotPhiBias <- as.numeric(partialResults$estTotPhiBias)
      partialResults$trueParameter <- as.logical(partialResults$trueParameter)
      # Value estimated only on telephone answers, with estimated selection probabilities
      benchmark <- crossprod(estimWeights[maskTel], Ytel[maskTel])
      trueWeightsBenchmark <- crossprod(trueWeights[maskTel], Ytel[maskTel])

      
      partialResults <- partialResults %>% 
        add_column(.before = 1L, expn = sum(pi)) %>% 
        add_column(.after = "expn", n = sum(I)) %>% 
        add_column(.after = "n", trueTotalYtel = trueTotalYtel) %>% 
        add_column(.after = "trueTotalYtel", expTotalYtel = expTotalYtel) %>% 
        add_column(.before = "estTotPhiBias", truePhiBias = trueTotalBias) %>% 
        add_column(.after = "truePhiBias", expPhiBias = expPhiBias) %>% 
        add_column(.after = "expPhiBias", estTotPhiYintTrueMP = estTotPhiYintHTTrueMP) %>% 
        add_column(.after = "estTotPhiYintTrueMP", estTotPhiYintEstMP = estTotPhiYintHTEstMP) %>% 
        add_column(.after = "estTotPhiYintEstMP", estTotPhiYtelTrueMP = estTotPhiYtelHTTrueMP) %>% 
        add_column(.after = "estTotPhiYtelTrueMP", estTotPhiYtelEstMP = estTotPhiYtelHTEstmMP) %>% 
        mutate(.after = "estTotPhiYtelEstMP",
               estTotYtelTrueMP = estTotPhiYintTrueMP + estTotPhiYtelTrueMP - estTotPhiBias) %>% 
        mutate(.after = "estTotYtelTrueMP", 
               estTotYtelEstMP = estTotPhiYintEstMP + 
                 estTotPhiYtelEstMP -
                 estTotPhiBias) %>% 
        add_column(.after = "estTotYtelEstMP", benchmark = benchmark) %>% 
        add_column(.after = "benchmark", TWBenchmark = trueWeightsBenchmark)
        
      #results <- rbind(results, partialResults)
    }
    
    clusterExport(cluster, 
                  varlist = "monoSim", 
                  envir = environment())
    
    ##browser()
    
    #results <- lapply(X = seq_len(K), FUN = monoSim)
    results <- parLapply(cluster, X = seq_len(K), fun = monoSim)
    
    stopCluster(cluster)
      

    if (fixZ)
    {
      parameters <- results[[1L]] %>% 
      select(parameter, probSelect, invMatrix, calculTotal) %>% 
      add_column(expSD = NA_real_)
      
      parameters[, c("expVarPhi1", "expVarPhi2", 
                     "expCovarPhi12", "expVarPhiDelta", 
                     "expCovarPhi1Delta", "covarPhi2Delta")] <- NA_real_
    
      for (l in seq_len(nrow(parameters)))
      {
        parameter <- parameters[l, ]
        
        if (parameter$parameter == "HT" && 
            parameter$invMatrix == "true" && 
            parameter$calculTotal == "full")
        {
          expVars <- var_estim_tot_BM(modeTotBiased = "HT", modeTotRef = "HT",
                                      calculTotal = "full",
                                      expY1 = expYint, expY2 = expYtel,
                                      covarY1 = covarYint, 
                                      covarY2 = covarYTel,
                                      piMat = piMat,
                                      pq1Mat = pq1Mat, pq2Mat = pq2Mat,
                                      phi = phi,
                                      subResults = TRUE)
          
          parameters[l, names(expVars)] <- expVars
        }
      }
    }
    
    
    results <- do.call("rbind", results)
    
    if (any((betaInt - betaTel)[-1L] != 0.0))
        MBtype <- "variable"
      else
        MBtype <- "constant"
    
    results <- results %>% 
      add_column(.before = "expn", N = N) %>% 
      add_column(.after = "TWBenchmark", sampling = sampling) %>% 
      add_column(.after = "sampling", YtelLaw = factor(YtelLaw)) %>% 
      add_column(.after = "YtelLaw", sdTel = sdTel) %>% 
      add_column(.after = "YtelLaw", YintLaw = factor(YintLaw)) %>% 
      add_column(.after = "YintLaw", sdInt = sdInt) %>% 
      add_column(.after = "YintLaw",
                 MBtype = factor(MBtype)) %>% 
      add_column(.after = "MBtype", phi = factor(phiType))
    
    if (fixZ)
    {
      suppressMessages(results <- results %>% inner_join(parameters, by = NULL))
    }
      
    
    
    # We calculate the real variance of the benchmark estimator
    if (fixZ)
    {
      sdTWBenchmark <- var_HT_seq_phi2(expY2 = Z %*% betaTel, 
                                       covarY2 = diag(sdTel^2L, N),
                                       piMat = piMat,
                                       pq1Mat = pq1Mat,
                                       pq2Mat = pq2Mat) %>% sqrt()
      
      results <- results %>% 
        mutate(sdTWBenchmark = sdTWBenchmark)
    }
    
    results
  }
```



Parameters:

-   the constance of the bias, up to a Gaussian noise (`constBias`)
-   the sampling type (`sampling`)
-   the law of $Y_{tel}$ (`YtelLaw`)
-   the law of $Y_{int}$ (`YintLaw`)
-   the state of $\phi$ (`phi`)


-   `trueTotalYtel`: $t_{tel} =\sum_{k \in U} y_{2k}$ for this iteration
-   `expTotalYtel` : $\mathbb{E}[t_{tel}]=\mathbb{E} [\sum_{k \in U} y_{2k}]$
-   `estTotPhiBias` : $t_{\phi \hat{\Delta y}}$
-   `truePhiBias` : $t_{\phi\Delta y}=\sum_{k\in U} \phi_k \Delta y_k$
-   `expPhiBias` : $\mathbb{E}[t_{\phi\Delta y}]$
-   `estTotPhiYintTrueMP` : $\hat{t}_{p,\phi y_1} = \sum_{k \in S_r}\frac{\phi_k y_{1k}}{\pi_k p_{1k}}$
-   `estTotPhiYintEstMP` : $\hat{t}_{\hat{p},\phi y_1} = \sum_{k \in S_r}\frac{\phi_k y_{1k}}{\pi_k \hat{p}_{1k}}$
-   `estTotPhiYintEstMP` : $\hat{t}_{\hat{p},\phi y_1} + \hat{t}_{\hat{p},\phi y_2} - t_{\phi \hat{\Delta y}}$
-   `benchmark` : $\sum_{k \in S_{mr}} \frac{y_{2k}}{\pi_k(1-p_{1k})p_{2k}}$
-   `calculTotal` : `full` if we calculate $\hat{t}_{\phi \hat{\Delta y}}$ (imputation on the entire population), `partial` if it is $t_{\phi \hat{\Delta y}}$ (on $S_{r\bullet}$)


## Measure bias evaluation

Evaluation of $K$ experiments

```{r}
K <- 1000L
```

```{r}
#| echo: false

results <- NULL
nbResults <- 0L

parameters <- expand_grid(constBias = c(TRUE, FALSE), 
                          sampling = "SRS",#c("SRS", "STSRS"),
                          YtelLaw = c("gaussian", "exponential"),
                          YintLaw = c("gaussian", "exponential"),
                          signAge = c("plus", "minus"),
                          phi = c("eq", "var"),
                          sdY = c(1.0, 2.0, 5.0)) %>% 
  mutate(sdY = ifelse(YtelLaw == "gaussian" | YintLaw == "gaussian", sdY, NA_real_)) %>% 
  mutate(signAge = ifelse(constBias, "none", signAge)) %>% # If the bias is constant the sign of Z
  distinct()# is of no interest


betaTelMinus <- betaTel
betaIntMinus <- betaInt

betaTelPlus <- betaTel
betaTelPlus[-1L] <- -betaTel[-1L]
betaIntPlus <- betaInt
betaIntPlus[-1L] <- -betaInt[-1L]


## 
parameters <- parameters[1:5L,]
for (i in seq_len(nrow(parameters)))
{
  tic()
  expParams <- parameters[i, ]
  #print(expParams)

  if (expParams$signAge == "none")
  {
    betaTelTemp <- betaIntTemp <- betaTel
    betaIntTemp[1L] <- betaInt[1L]
  }
  else if (expParams$signAge == "plus")
  {
    betaIntTemp <- betaIntPlus
    betaTelTemp <- betaTelPlus
  }
  else if (expParams$signAge == "minus")
  {
    betaIntTemp <- betaIntMinus
    betaTelTemp <- betaTelMinus
  }
  
  expResults <- simulationUncounf(N, K = K,
                                  Z = Z, fixZ = TRUE,
                                  sampling = expParams$sampling,
                                  alphaInt = alphaInt,
                                  alphaTel = alphaTel,
                                  betaInt = betaIntTemp,
                                  betaTel = betaTelTemp,
                                  YtelLaw = expParams$YtelLaw,
                                  YintLaw = expParams$YintLaw,
                                  phi = expParams$phi,
                                  sdInt = expParams$sdY,
                                  sdTel = expParams$sdY,
                                  seed = 200L)
  
  expResults <- expResults %>% 
    rename(sd = sdInt) %>% 
    select(-sdTel) %>% 
    mutate(signAge = expParams$signAge)

  if (i == 1L)
    expNbResults <- nrow(expResults)
  
  nbResults <- nbResults + expNbResults
  expResults <- expResults %>% 
    add_column(.before = 1L, 
               experiment = factor(rep(nbResults + seq_len(K), 
                                       each = expNbResults / K)))
  
  results <- rbind(results, expResults)
  
  t <- toc(quiet = TRUE)
  
  glue("{round(unname(t$toc - t$tic))}s ({i} / {nrow(parameters)})") %>% print()
}

rm(i, 
   betaIntMinus, betaTelMinus, 
   betaIntPlus, betaTelPlus, 
   betaIntTemp, betaTelTemp, 
   nbResults, t)


results$parameter <- as.factor(results$parameter)
results$probSelect <- as.factor(results$probSelect)
results$invMatrix <- as.factor(results$invMatrix)
results$calculTotal <- as.factor(results$calculTotal)

results <- results %>% 
  mutate(.after = "estTotPhiBias", diffPhiBias = estTotPhiBias - truePhiBias) %>% 
  mutate(.after = "estTotPhiYtelEstMP", 
         diffTotalYtelEstMP = estTotYtelEstMP - trueTotalYtel) %>% 
  mutate(.after = "estTotPhiYtelTrueMP",
         diffTotalYtelTrueMP = estTotYtelTrueMP - trueTotalYtel) %>% 
  mutate(.after = diffTotalYtelTrueMP, diffBenchmark = benchmark - trueTotalYtel)
```

```{r}
results %>% 
  filter(parameter == "HT", probSelect == "true", invMatrix == "true", calculTotal == "full") %>% 
  group_by(sampling, YintLaw, YtelLaw, sd, signAge, MBtype, phi) %>% 
  summarise(K = n(),
            estVarEstim = var(estTotYtelTrueMP),
            expVarEstim = mean(expVarEstim),
            estVarPhi1 = var(estTotPhiYintTrueMP),
            expVarPhi1 = mean(expVarPhi1),
            estVarPhi2 = var(estTotPhiYtelTrueMP),
            expVarPhi2 = mean(expVarPhi2),
            estCovarphi12 = cov(estTotPhiYintTrueMP, estTotYtelTrueMP),
            expCovarPhi12 = mean(expCovarPhi12),
            estCovarphi1Delta = cov(estTotPhiYintTrueMP, estTotPhiBias),
            expCovarPhi1Delta = mean(expCovarPhi1Delta),
            estVarPhiDelta = var(estTotPhiBias),
            expVarPhiDelta = mean(expVarPhiDelta),
            estCovarphi2Delta = cov(estTotPhiYtelTrueMP, estTotPhiBias),
            expCovarPhi2Delta = mean(expCovarPhi2Delta))
```

```{r}
temp <- results %>% 
  filter(parameter == "HT", probSelect == "true", invMatrix == "true", calculTotal == "full")

varsPhi1 <- numeric(nrow(temp))

for (i in 2:nrow(temp))
  varsPhi1[i] <- var(temp[1:i, "estTotPhiYintTrueMP"])

plot(varsPhi1[-1])
```


## Ex : Gaussian constant measure bias

Results of each parameter for the case of SRS with **constant** measure bias and Gaussian laws (with $\sigma =1$)

### Measure bias total

$$\text{relError} = \frac{1}{K}\sum_{k=1}^K \frac{\hat{t}_{\phi\Delta y,k}-t_{\phi\Delta y,k}}{\mathbb{E}[t_{\phi\Delta y}]}$$

$$\text{relRMSE} = \frac{\sqrt{\frac{1}{K}\sum_{k=1}^K (\hat{t}_{\phi\Delta y,k}-t_{\phi\Delta y,k})^2}}{|\mathbb{E}[t_{\phi\Delta y}]|}$$

```{r}
results %>% 
  filter(YtelLaw == "gaussian", YintLaw == "gaussian", 
         sampling == "SRS", MBtype == "constant",
         probSelect != "true", sd == 1.0) %>% 
  select(-sampling, -MBtype) %>% 
  group_by(K = n(),
           phi, parameter, probSelect, invMatrix, calculTotal) %>% 
  summarise(relError = round(mean(diffPhiBias / abs(expPhiBias)), 4L), 
            relRMSE = round(sqrt(mean(diffPhiBias^2L / expPhiBias^2L)), 4L)) %>% 
  ungroup() %>% 
  arrange(relRMSE)
```

### telephone total estimation

```{r}
results %>% 
  filter(YtelLaw == "gaussian", YintLaw == "gaussian", 
         sampling == "SRS", MBtype == "constant",
         probSelect != "true", sd == 1.0) %>% 
  select(-sampling, -MBtype) %>% 
  group_by(phi, parameter, probSelect, invMatrix, calculTotal) %>% 
  summarise(K = n(),
            #reldiffTotalTrueMean = round(mean(diffTotalYtelTrueMP / abs(expTotalYtel)) , 4L), 
            relTotalError = round(mean(diffTotalYtelEstMP / abs(expTotalYtel)), 4L),
            relDiffBenchmarkMean = round(mean(diffBenchmark / abs(expTotalYtel)), 4L),
            #relRMSETrue = round(sqrt(mean(diffTotalYtelTrueMP^2L / expTotalYtel^2L)), 4L),
            relRMSEParam = round(sqrt(mean(diffTotalYtelEstMP^2L / expTotalYtel^2L)), 4L),
            relExpSD = round(mean(expSD / expTotalYtel), 4L),
            relRMSEBenchmark = round(sqrt(mean(diffBenchmark^2L / expTotalYtel^2L)), 4L),
            relSDTWBenchmark = mean(SDTWBenchmark / abs(expTotalYtel))) %>% 
  ungroup() %>% 
  arrange(relRMSEParam)
```

## Ex : Gaussian variable measure bias

Results of each parameter for the case of SRS with **variable** measure bias and Gaussian laws. First we focus on the bias:



```{r}
temp <- results %>% 
  filter(YtelLaw == "gaussian", YintLaw == "gaussian", 
         sampling == "SRS", MBtype == "variable", trueParameter) %>% 
  select(-sampling, -MBtype) %>% 
  group_by(sd, phi, parameter, probSelect, invMatrix, calculTotal) %>% 
  summarise(#reldiffTotalTrueMean = round(mean(diffTotalYtelTrueMP / abs(expTotalYtel)) , 4L), 
            relTotalError = round(mean(diffTotalYtelEstMP / abs(expTotalYtel)) , 4L),
            relDiffBenchmarkMean = round(mean(diffBenchmark / abs(expTotalYtel)), 4L),
            #relRMSETrue = round(sqrt(mean(diffTotalYtelTrueMP^2L / expTotalYtel^2L)), 4L),
            relRMSEParam = round(sqrt(mean(diffTotalYtelEstMP^2L / expTotalYtel^2L)), 4L),
            relRMSEBenchmark = round(sqrt(mean(diffBenchmark^2L / expTotalYtel^2L)), 4L),
            relSdTWBenchmark = mean(expSD / abs(expTotalYtel))) %>% 
  ungroup() %>% 
  group_by(sd) %>% 
  arrange(abs(relTotalError), .by_group = TRUE)

temp %>% 
  select(-relRMSEParam, -relRMSEBenchmark, -relSdTWBenchmark)
```


And now the RMSE:

```{r}
temp %>% 
  select(-relTotalError, -relTotalError, -relDiffBenchmarkMean) %>% 
  arrange(relRMSEParam, .by_group = TRUE)
```


It is better to have $\phi_k \equiv \phi$ compared to $\phi_k = \frac{k}{N}$. Summing the bias on exclusively $S_{r\bullet}$ seems to be effective

```{r}
temp %>%
  mutate(ratioRMSE = relRMSEParam / relRMSEBenchmark) %>% 
  ggplot() + geom_histogram(aes(x = ratioRMSE)) +
  ggtitle("Ratio RMSE parameter compared to RMSE benchmark")
```

Here are the parameters that offer a better RMSE than the benchmark:
```{r}
temp %>% 
  select(-relTotalError, -relDiffBenchmarkMean) %>% 
  filter(relRMSEParam <= relRMSEBenchmark) %>% 
  arrange(relRMSEParam)
```

Estimators that are the most present:
```{r}
temp %>% 
  select(-relTotalError, -relDiffBenchmarkMean) %>% 
  filter(relRMSEParam <= relRMSEBenchmark) %>% 
  group_by(phi, parameter, probSelect, invMatrix, calculTotal) %>% 
  summarize(n = n()) %>% 
  arrange(-n)
```

And the parameters that offer the worse RMSE compared to the benchmark:

```{r}
temp %>% 
  slice_max(relRMSEParam, n = 5L)
```


## More general cases

Optimal RMSE for each condition:

```{r}
temp <- results %>% 
  filter(trueParameter, MBtype == "variable") %>% 
  group_by(YintLaw, YtelLaw, phi, sampling, parameter, probSelect, invMatrix, calculTotal) %>% 
  summarise(#reldiffTotalTrueMean = round(mean(diffTotalYtelTrueMP / abs(expTotalYtel)) , 4L), 
            relTotalError = round(mean(diffTotalYtelEstMP / abs(expTotalYtel)) , 4L),
            relDiffBenchmarkMean = round(mean(diffBenchmark / abs(expTotalYtel)), 4L),
            #relRMSETrue = round(sqrt(mean(diffTotalYtelTrueMP^2L / expTotalYtel^2L)), 4L),
            relRMSEParam = round(sqrt(mean(diffTotalYtelEstMP^2L / expTotalYtel^2L)), 4L),
            relRMSEBenchmark = round(sqrt(mean(diffBenchmark^2L / expTotalYtel^2L)), 4L)) %>% 
  ungroup() 

temp %>% 
  group_by(YintLaw, YtelLaw, sampling) %>% 
  slice_min(relRMSEParam)
```

Here are the parameters that offer a better RMSE than the benchmark:
```{r}
temp %>% 
  filter(relRMSEParam <= relRMSEBenchmark) %>% 
  group_by(YintLaw, YtelLaw)
```
