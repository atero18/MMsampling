```{r}
library(dplyr)
options(dplyr.summarise.inform = FALSE)
library(tidyr)
library(glue)
library(tibble)
library(parallel)
library(tictoc)
library(ggplot2)
```

```{r}
devtools::load_all()
```

# Linear models on both modes

## Building constants

```{r}
set.seed(145L)
```

```{r}
N <- 1000L
phi <- rep(0.5, N)
```

Creating independent covariates

```{r}
p <- 1L

sex <- sample(c(0L, 1L), replace = TRUE, size = N, prob = c(0.5, 0.5))
age <- rnorm(n = N, mean = sex * 41.1 + (1L - sex) * 43.9, sd = 10.0)
age[age < 0.0] <- 0.0

Z <- data.frame(const = 1.0, 
                age = age, 
                sex = sex)

rm(age)
sex <- factor(sex)
levels(sex) <- c("Woman", "Man")
```

```{r}
summary(Z)
```

```{r}
data <- Z[, c("sex", "age")]
data$sex <- sex
ggplot(data) + 
  geom_density(aes(x = age, colour = sex)) +
  ggtitle("Age ~ sex")
rm(data)
```

```{r}
Z <- as.matrix(Z)
```

Creating parameters for two modes : "int" and "tel". `delta` is defined such that the average measure bias is equal to 1. It depends on `Z`.

```{r}
betaTel <- c(7.0, -0.1, 4.0)
print(betaTel)
delta <- c(1.0, -2.0 * mean(Z[, "age"])^-1L, 2.0 * N / sum(Z[, "sex"]))
betaInt <- betaTel + delta
  

print(betaInt)
```

$Y_{int}$ and $Y_{tel}$ expectations depending on `Z`:

```{r}
data.frame(tel = Z %*% betaTel, int = Z %*% betaInt) %>% 
  pivot_longer(cols = c("tel", "int"), names_to = "mode", values_to = "value") %>% 
  ggplot() + geom_density(aes(x = value, colour = mode))

glue("average value for telephone: {mean(Z %*% betaTel)}")
glue("average value for internet: {mean(Z %*% betaInt)}")
```


```{r}
totBias <- sum(Z %*% delta)
glue("total bias on U: {totBias}")
meanBias <- totBias / N
glue("average bias on U: {meanBias}")
```

We simulate a mode selection MAR (Missing At Random) under a logistic model, with $Z$ as variable:

```{r}
# With MAR

expit <- function(x) 1.0 / (1.0 + exp(-x))

alphaInt <- c(0.7, -0.02, -0.5)
pInt <- expit(Z %*% alphaInt) %>% as.vector()

alphaTel <- c(0.3, 0.02, -0.5)
pTel <- expit(Z %*% alphaTel) %>% as.vector()
```

Here are some details about the $p_{int}$ and $p_{tel}$:

```{r}
data.frame(mode = factor(rep(c("int", "tel"), each = N)), 
           prob = c(pInt, pTel)) %>% 
  ggplot() + 
  geom_density(aes(x = prob, color = mode)) +
  ggtitle("Distribution of p_int and p_tel")
```

```{r}
pInt[sex == "Man"] %>% summary()
pInt[sex == "Woman"] %>% summary()
```

```{r}
cat("internet probabilities:\n")
summary(pInt) %>% print()
cat("telephone probabilities:\n")
summary(pTel) %>% print()
```

## Simulation functions

Randomly affect a mode (or non-response) to each unit

```{r}
gen_choice_bimode <- function(I, p1, p2, mode1 = "int", mode2 = "tel")
{
  N <- length(p1)
  
  R1 <- runif(N) <= p1
  R2 <- runif(N) <= p2
  
  modes <- rep("nr", N)
  modes[R1] <- mode1
  
  modes[!R1 & R2] <- mode2
  
  modes[!I] <- "nr"
  
  modes
}
```

```{r}
simulationUncounf <- 
  function(N,
           meanZ = rep(0.0, length(alphaInt)), 
           covarZ = diag(1.0, length(alphaInt)), 
           fixZ = TRUE,
           sampling = "SRS",
           alphaInt, alphaTel, 
           betaInt, betaTel, 
           YintLaw = "gaussian", YtelLaw = "gaussian",
           sdInt = 1.0, sdTel = 1.0, 
           phi = rep(0.5, N), K = 1000L,
           Z = NULL,
           n = ceiling(N / 4L))
  {
    
    nbCores <- detectCores() - 1L
    cluster <- makeCluster(nbCores)
    
    # Making clusters random-independants
    RNGkind("L'Ecuyer-CMRG")
    
    seed <- .Random.seed
    
    clusterSetRNGStream(cl = cluster, iseed = seed)
    
    clusterEvalQ(cluster, library(dplyr))
    clusterEvalQ(cluster, library(tibble))
    clusterEvalQ(cluster, library(MMsampling))
    
    clusterExport(cluster, varlist = c("sampling", 
                                       "betaInt", "betaTel", 
                                       "YintLaw", "YtelLaw", 
                                       "sdInt", "sdTel", 
                                       "n"),
                  envir = environment())
    
    expit <- function(x) 1.0 / (1.0 + exp(-x))

    if (!is.null(Z))
    {
      fixZ <- TRUE
      clusterExport(cluster, 
                    varlist = "Z",
                    envir = environment())
    }
    else if (fixZ)
    {
      Z <- mvtnorm::rmvnorm(N, mean = meanZ, sigma = covarZ, checkSymmetry = TRUE)
      clusterExport(cluster,
                    varlist = "Z",
                    envir = environment())
    }
      
    clusterExport(cluster, 
                  varlist = "fixZ",
                  envir = environment())
    
    if (fixZ)
    {
      pInt <- expit(Z %*% alphaInt) %>% as.numeric()
      pTel <- expit(Z %*% alphaTel) %>% as.numeric()
      clusterExport(cluster, 
                    varlist = c("pInt", "pTel"),
                    envir = environment())
    }
    else
    {
      clusterExport(cluster, 
                    varlist = c("meanZ", "covarZ",
                                "alphaInt", "alphaTel", 
                                "expit"),
                    envir = environment())
    }
    
    clusterExport(cluster, "gen_choice_bimode")
      
    
    if (class(phi) == "character")
      phiType <- phi
    else
      phiType <- "vector"
    
    if (phi == "eq")
      phi <- rep(0.5, N)
  
    else if (phi == "var")
      phi <- seq_len(N) / N
    
    else if (phi == "bestProb")
    {
      phi <- ifelse(pInt >= 0.5, 1.0, 0.0)
    }
    
    clusterExport(cluster, 
                  varlist = "phi", 
                  envir = environment())
    
    monoSim <- function(...)
    {
      nbExperiments <- 10L
      
      partialResults <- data.frame(parameter = character(nbExperiments),
                                   trueParameter = logical(nbExperiments),
                                   probSelect = character(nbExperiments),
                                   invMatrix = character(nbExperiments),
                                   calculTotal = character(nbExperiments),
                                   estTotPhiBias = numeric(nbExperiments))
      
      row <- 1L
      
      if (!fixZ)
      {
        Z <- mvtnorm::rmvnorm(N, mean = meanZ, sigma = covarZ, checkSymmetry = TRUE)
        pInt <- expit(Z %*% alphaInt)
        pTel <- expit(Z %*% alphaTel)
      }
        
      
      if (sampling == "SRS")
      {
        selectedSample <- sample(seq_len(N), size = n, replace = FALSE)
        pi <- rep(n / N, N)
        I <- rep(FALSE, N)
        I[selectedSample] <- TRUE
        rm(selectedSample)
      }
      
      # Mode selection simulation
      modes <- gen_choice_bimode(I, pInt, pTel)
      trueProbsSelect <- rep(NA_real_, N)
      maskInt <- modes == "int"
      maskTel <- modes == "tel"
      trueProbsSelect[maskInt] <- pInt[maskInt]
      trueProbsSelect[maskTel] <- ((1.0 - pInt) * pTel)[maskTel]
      
      trueWeights <- (pi * trueProbsSelect)^-1L
    
      # Estimation of mode selection probabilities
      estimProbsSelect <- 
        MMsampling::estim_response_prob_sequential(I, Z, modes, c("int", "tel"))$unconditional
    
      estimWeights <- (pi * estimProbsSelect)^-1L
      
       # Affecting values to Y_int and Y_tel
      if (YtelLaw == "gaussian")
      {
        Ytel <- Z %*% betaTel + rnorm(n = N, sd = sdTel)
        expectedTotalYtel <- sum(Z %*% betaTel)
      }
      else if (YtelLaw == "exponential")
      {
        Ytel <- rexp(n = N, rate = abs(Z %*% betaTel)^-1L)
        expectedTotalYtel <- sum(abs(Z %*% betaTel))
      }
      
      trueTotalYtel <- sum(Ytel)
      
      if (YintLaw == "gaussian")
        Yint <- Z %*% betaInt + rnorm(n = N, sd = sdInt)
        
      else if (YintLaw == "exponential")
        Yint <- rexp(n = N, rate = abs(Z %*% betaInt)^-1L)
      
      deltas <- Yint - Ytel
      
    
      # Evaluating the measure bias total (random value)
      trueTotalBias <- crossprod(phi, deltas)
      expectedPhiBias <- t(phi) %*% Z %*% (betaInt - betaTel)
      
      # Creating the observed outcome vector
      Yobs <- rep(NA_real_, N)
      Yobs[maskInt] <- Yint[maskInt]
      Yobs[maskTel] <- Ytel[maskTel]
      
      sample <- MMsampling:::MMSample$new(Z = Z, pi = pi, I = I, 
                             modes = modes, Yobs = Yobs, phi = phi)
      
      # Full HT estimation, with full population matrix (Z^tZ)^-1 and
      # known probabilities
        resEval <-
          estim_delta_MCO(sample$Z, sample$Yobs, sample$modes,
                                 "int", "tel", "HT", "HT", pi,
                          trueProbsSelect, sampleMatrix = FALSE) %>%
          estim_MB_by_MCO(Z, phi = phi) %>%
          sum()
    
        partialResults[row,] <- 
          c(parameter = "HT", trueParameter = FALSE,
            probSelect = "true", invMatrix = "true",
            calculTotal = "full", estTotPhiBias = resEval)
        
        row <- row + 1L
    
        # Full HT estimation, with sample matrix (Z_S^TZ_S)^-1 and
        # known probabilities
        resEval <-
          estim_delta_MCO(sample$Z, sample$Yobs, sample$modes,
                                 "int", "tel", "HT", "HT", pi,
                          trueProbsSelect, sampleMatrix = TRUE) %>%
          estim_MB_by_MCO(Z, phi = phi) %>%
          sum()
    
        partialResults[row,] <- c(parameter = "HT", trueParameter = FALSE,
                  probSelect = "true", invMatrix = "sample", 
                  calculTotal = "full", estTotPhiBias = resEval)
        
        row <- row + 1L
        
        # G-COMP estimation, <=> double MCO estimation
      # tic()
      estimdelta <- estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                        "int", "tel", "MCO", "MCO", pi, NULL)
      
      resEvalFull <- estimdelta %>% 
        estim_MB_by_MCO(Z, phi = phi) %>% 
        sum()
      
      resEvalHT <- estimdelta %>% 
        estim_MB_by_MCO(Z, phi = phi, weights = estimWeights, mask = maskInt) %>% 
        sum()
      # toc() %>% print()
      
      
      
      partialResults[c(row, row + 1L),] <- 
        data.frame(parameter = "G-COMP", trueParameter = TRUE,
          probSelect = "null", 
          invMatrix = "null", calculTotal = c("full", "partial"),
          estTotPhiBias = c(resEvalFull, resEvalHT))
      
      row <- row + 2L
      
      # Estimation on a unique MCO for Y1 and Y2, with beta X and only a constant
      # delta for the estimation of the measure bias
      deltaEval <- estim_delta_MCO_unique_model_const(Z, Yobs, modes, "int", "tel")
      resEvalFull <- sum(phi) * deltaEval
      resEvalHT <- crossprod(phi[maskInt] * estimWeights[maskInt], deltaEval)
      
      partialResults[c(row, row + 1L),] <- 
        data.frame(parameter = "MCO_unique",
                   trueParameter = TRUE,
                   probSelect = "null", calculTotal = c("full", "partial"),
                   invMatrix = "null", 
                   estTotPhiBias = c(resEvalFull, resEvalHT))
      
      
      row <- row + 2L
      
      # Full HT estimation, with full population matrix (Z^tZ)^-1 and
      # unknown probabilities
      # tic()
      estimdelta <- 
        estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                             "int", "tel", "HT", "HT", pi, 
                        estimProbsSelect, sampleMatrix = FALSE)
      
      resEvalFull <- estimdelta %>% 
        estim_MB_by_MCO(Z, phi = phi) %>% 
        sum()
      
      resEvalHT <- estimdelta %>% 
        estim_MB_by_MCO(Z, phi = phi, weights = estimWeights, mask = maskInt) %>% 
        sum()
    
      # toc() %>% print()
     
      
      partialResults[c(row, row + 1L),] <- 
        data.frame(parameter = "HT", trueParameter = TRUE,
                   probSelect = "estimation", invMatrix = "true", 
                   calculTotal = c("full", "partial"), 
                   estTotPhiBias = c(resEvalFull, resEvalHT))
      
      row <- row + 2L
      
      # Full HT estimation, with sample matrix (Z_S^TZ_S)^-1 and
      # unknown probabilities
      # tic()
      estimdelta <- 
        estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                             "int", "tel", "HT", "HT", pi, 
                        estimProbsSelect, sampleMatrix = TRUE) 
      
      
      resEvalFull <- estimdelta %>% 
        estim_MB_by_MCO(Z, phi = phi) %>% 
        sum()
      
      resEvalHT <- estimdelta %>% 
        estim_MB_by_MCO(Z, phi = phi, weights = estimWeights, mask = maskInt) %>% 
        sum()
    
      # toc() %>% print()
      
      partialResults[c(row, row + 1L),] <- 
        data.frame(parameter = "HT", trueParameter = TRUE,
                   probSelect = "estimation", invMatrix = "sample", 
                   calculTotal = c("full", "partial"), 
                   estTotPhiBias = c(resEvalFull, resEvalHT))
      
      row <- row + 2L
      
      estTotalPhiYintHTTrueMP <- 
        phi[maskInt] * 
        trueWeights[maskInt] * 
        Yint[maskInt]
      
      estTotalPhiYintHTTrueMP <- sum(estTotalPhiYintHTTrueMP)
      
      estTotalPhiYtelHTTrueMP <- 
        (1.0 - phi[maskTel]) * 
        trueWeights[maskTel] * 
        Ytel[maskTel]
      
      estTotalPhiYtelHTTrueMP <- sum(estTotalPhiYtelHTTrueMP)
    
      estTotalPhiYintHTEstMP <-
        phi[maskInt] *
        estimWeights[maskInt] *
        Yint[maskInt]
    
      estTotalPhiYintHTEstMP <- sum(estTotalPhiYintHTEstMP)
    
      estTotalPhiYtelHTEstmMP <-
        (1.0 - phi[maskTel]) *
        estimWeights[maskTel] *
        Ytel[maskTel]
    
      estTotalPhiYtelHTEstmMP <- sum(estTotalPhiYtelHTEstmMP)
      
      ## Don't know why but `estTotPhiBias` and `trueParameter` are
      ##  automatically converted as character
      partialResults$estTotPhiBias <- as.numeric(partialResults$estTotPhiBias)
      partialResults$trueParameter <- as.logical(partialResults$trueParameter)
      # Value estimated only on telephone answers, with estimated selection probabilities
      benchmark <- crossprod(estimWeights[maskTel], Ytel[maskTel])
      trueWeightsBenchmark <- crossprod(trueWeights[maskTel], Ytel[maskTel])

      
      if (any((betaInt - betaTel)[-1L] != 0.0))
        MBtype <- "variable"
      else
        MBtype <- "constant"
      
      partialResults <- partialResults %>% 
        add_column(.before = 1L, trueTotalYtel = trueTotalYtel) %>% 
        add_column(.after = "trueTotalYtel", expectedTotalYtel = expectedTotalYtel) %>% 
        add_column(.before = "estTotPhiBias", truePhiBias = trueTotalBias) %>% 
        add_column(.after = "truePhiBias", expectedPhiBias = expectedPhiBias) %>% 
        add_column(.after = "expectedPhiBias", estTotalPhiYintTrueMP = estTotalPhiYintHTTrueMP) %>% 
        add_column(.after = "estTotalPhiYintTrueMP", estTotalPhiYintEstMP = estTotalPhiYintHTEstMP) %>% 
        add_column(.after = "estTotalPhiYintEstMP", estTotalPhiYtelTrueMP = estTotalPhiYtelHTTrueMP) %>% 
        add_column(.after = "estTotalPhiYtelTrueMP", estTotalPhiYtelEstMP = estTotalPhiYtelHTEstmMP) %>% 
        mutate(.after = "estTotalPhiYtelEstMP",
               estTotalYtelTrueMP = estTotalPhiYintTrueMP + estTotalPhiYtelTrueMP - estTotPhiBias) %>% 
        mutate(.after = "estTotalYtelTrueMP", 
               estTotalYtelEstMP = estTotalPhiYintEstMP + 
                 estTotalPhiYtelEstMP -
                 estTotPhiBias) %>% 
        add_column(.after = "estTotalYtelEstMP", benchmark = benchmark) %>% 
        add_column(.after = "benchmark", trueWeightsBenchmark = trueWeightsBenchmark) %>% 
        add_column(.after = "trueWeightsBenchmark", sampling = sampling) %>% 
        add_column(.after = "sampling", YtelLaw = factor(YtelLaw)) %>% 
        add_column(.after = "YtelLaw", YintLaw = factor(YintLaw)) %>% 
        add_column(.after = "YintLaw",
                   MBtype = factor(MBtype)) %>% 
        add_column(.after = "MBtype", phi = factor(phiType))
      
      partialResults
      #results <- rbind(results, partialResults)
    }
    
    clusterExport(cluster, 
                  varlist = "monoSim", 
                  envir = environment())
    
    results <- parLapply(cluster, X = seq_len(K), fun = monoSim)
    
    stopCluster(cluster)
    
    results <- do.call("rbind", results)
    
    # We calculate the real variance of the benchmark estimator
    if (fixZ)
    {
      if (sampling == "SRS")
      {
        piMat <- matrix(n * (n - 1L) / (N * (N - 1L)), nrow = N, ncol = N)
        diag(piMat) <- n / N
      }
      
      pq1Mat <- pInt %*% t(pInt)
      diag(pq1Mat) <- pInt
      
      pq2Mat <- pTel %*% t(pTel)
      diag(pq2Mat) <- pTel
      
      sdTrueWeightsBenchmark <- var_HT_seq_phi2(expY2 = Z %*% betaTel, 
                                     covarY2 = diag(sdTel^2L, N),
                                     piMat = piMat,
                                     pq1Mat = pq1Mat,
                                     pq2Mat = pq2Mat) %>% sqrt()
      
      results <- results %>% 
        mutate(sdTrueWeightsBenchmark = sdTrueWeightsBenchmark)
    }
    
    
    
  }
```



Parameters:

-   the constance of the bias, up to a Gaussian noise (`constBias`)
-   the sampling type (`sampling`)
-   the law of $Y_{tel}$ (`YtelLaw`)
-   the law of $Y_{int}$ (`YintLaw`)
-   the state of $\phi$ (`phi`)

```{r}
#| echo: false

# simulation1 <- function(constBias = FALSE,
#                         sampling = "SRS",
#                         YtelLaw = "gaussian", 
#                         YintLaw = "gaussian",
#                         phiType = "eq",
#                         addFalseParameters = FALSE,
#                         ...)
# {
#   
#   if (phiType == "eq")
#     phi <- rep(0.5, N)
#   
#   else if (phiType == "var")
#     phi <- seq_len(N) / N
#   
#   else if (phiType == "bestProb")
#   {
#     phi <- ifelse(pInt >= 0.5, 1.0, 0.0)
#   }
#   
#   # Handling sampling
#  
#   n <- ceiling(N / 4L)
#   
#   
#   if (sampling == "SRS")
#   {
#     selectedSample <- sample(seq_len(N), size = n, replace = FALSE)
#     pi <- rep(n / N, N)
#     I <- rep(FALSE, N)
#     I[selectedSample] <- TRUE
#     rm(selectedSample)
#   }
#   
#   else if (sampling == "STSRS")
#   {
#     nbMen <- sum(sex == "Man")
#     selectedSampleMen <- sample(which(sex == "Man"),
#                                 size = ceiling(2L * nbMen / 3L),
#                                 replace = FALSE)
# 
#     nbWomen <- sum(sex == "Woman")
#     selectedSampleWomen <- sample(which(sex == "Woman"),
#                                   size = ceiling(nbWomen / 3L),
#                                   replace = FALSE)
#     I <- rep(FALSE, N)
#     I[selectedSampleMen] <- TRUE
#     I[selectedSampleWomen] <- TRUE
#     rm(selectedSampleMen)
#     rm(selectedSampleWomen)
#     pi <- rep(1.0 / 3.0, N)
#     pi[sex == "Man"] <- 2.0 / 3.0
#   }
# 
#   # Mode selection simulation
#   modes <- gen_choice_bimode(I, pInt, pTel)
#   trueProbsSelect <- rep(NA_real_, N)
#   maskInt <- modes == "int"
#   maskTel <- modes == "tel"
#   trueProbsSelect[maskInt] <- pInt[maskInt]
#   trueProbsSelect[maskTel] <- ((1.0 - pInt) * pTel)[maskTel]
#   
#   
#   trueWeights <- (pi * trueProbsSelect)^-1L
#   
#   # Estimation of mode selection probabilities
#   estimProbsSelect <- 
#     estim_response_prob_sequential(I, Z, modes, c("int", "tel"))$unconditional
#   
#   estimWeights <- (pi * estimProbsSelect)^-1L
#   
#   # Affecting values to Y_int and Y_tel
#   if (YtelLaw == "gaussian")
#   {
#     Ytel <- Z %*% betaTel + rnorm(n = N, sd = 1.0)
#     expectedTotalYtel <- sum(Z %*% betaTel)
#   }
#   else if (YtelLaw == "exponential")
#   {
#     Ytel <- rexp(n = N, rate = abs(Z %*% betaTel)^-1L)
#     expectedTotalYtel <- sum(abs(Z %*% betaTel))
#   }
#     
#   
#   trueTotalYtel <- sum(Ytel)
#   
#   # Case when the measure bias is constant, up to a white noise
#   if (constBias)
#   {
#     betaIntBis <- betaTel
#     betaIntBis[1L] <- betaTel[1L] + 1.0
#   }
#   else
#     betaIntBis <- betaInt
# 
#   if (YintLaw == "gaussian")
#     Yint <- Z %*% betaIntBis + rnorm(N, 0.0, 1.0)
#     
#   else if (YintLaw == "exponential")
#     Yint <- rexp(n = N, rate = abs(Z %*% betaIntBis)^-1L)
#   
#   deltas <- Yint - Ytel
#   
# 
#   # Evaluating the measure bias total (random value)
#   trueTotalBias <- sum(phi * deltas)
#   
#   if (constBias)
#     expectedPhiBias <- sum(phi) * (betaInt[1L] - betaTel[1L])
#   else
#     expectedPhiBias <- t(phi) %*% Z %*% (betaInt - betaTel)
#   
#   
#   # Creating the observed outcome vector
#   Yobs <- rep(NA_real_, N)
#   Yobs[maskInt] <- Yint[maskInt]
#   Yobs[maskTel] <- Ytel[maskTel]
#   
#   sample <- MMSample$new(Z = Z, pi = pi, I = I, 
#                          modes = modes, Yobs = Yobs, phi = phi)
#   
#   results <- data.frame(parameter = character(),
#                         trueParameter = logical(),
#                         probSelect = character(),
#                         invMatrix = character(),
#                         calculTotal = character(),
#                         estTotPhiBias = numeric())
#   
#   # Calculate false parameters with true mode selection probabilities
#   if (addFalseParameters)
#   {
#     # Full HT estimation, with full population matrix (Z^tZ)^-1 and
#     # known probabilities
#     resEval <-
#       estim_delta_MCO(sample$Z, sample$Yobs, sample$modes,
#                              "int", "tel", "HT", "HT", pi,
#                       trueProbsSelect, sampleMatrix = FALSE) %>%
#       estim_MB_by_MCO(Z, phi = phi) %>%
#       sum()
# 
#     results <- results %>%
#       add_row(parameter = "HT", trueParameter = FALSE,
#               probSelect = "true", invMatrix = "true",
#               calculTotal = "full", estTotPhiBias = resEval)
# 
#     # Full HT estimation, with sample matrix (Z_S^TZ_S)^-1 and
#     # known probabilities
#     resEval <-
#       estim_delta_MCO(sample$Z, sample$Yobs, sample$modes,
#                              "int", "tel", "HT", "HT", pi,
#                       trueProbsSelect, sampleMatrix = TRUE) %>%
#       estim_MB_by_MCO(Z, phi = phi) %>%
#       sum()
# 
#     results <- results %>%
#       add_row(parameter = "HT", trueParameter = FALSE,
#               probSelect = "true", invMatrix = "sample", 
#               calculTotal = "full", estTotPhiBias = resEval)
#   }
#   
#   # G-COMP estimation, <=> double MCO estimation
#   # tic()
#   estimdelta <- estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
#                     "int", "tel", "MCO", "MCO", pi, NULL)
#   
#   resEvalFull <- estimdelta %>% 
#     estim_MB_by_MCO(Z, phi = phi) %>% 
#     sum()
#   
#   resEvalHT <- estimdelta %>% 
#     estim_MB_by_MCO(Z, phi = phi, weights = estimWeights, mask = maskInt) %>% 
#     sum()
#   # toc() %>% print()
#   
#   
#   
#   results <- results %>% 
#     add_row(parameter = "G-COMP", trueParameter = TRUE,
#             probSelect = "null", 
#             invMatrix = "null", calculTotal = c("full", "partial"),
#             estTotPhiBias = c(resEvalFull, resEvalHT))
#   
#   
#   # Estimation on a unique MCO for Y1 and Y2, with beta X and only a constant
#   # delta for the estimation of the measure bias
#   deltaEval <- estim_delta_MCO_unique_model_const(Z, Yobs, modes, "int", "tel")
#   resEvalFull <- sum(phi) * deltaEval
#   resEvalHT <- sum(phi[maskInt] * estimWeights[maskInt] * deltaEval)
#   
#   results <- results %>% 
#     add_row(parameter = "MCO_unique", trueParameter = TRUE,
#             probSelect = "null", calculTotal = c("full", "partial"),
#             invMatrix = "null", estTotPhiBias = c(resEvalFull, resEvalHT))
#   
#   
#   
#   
#   # Full HT estimation, with full population matrix (Z^tZ)^-1 and
#   # unknown probabilities
#   # tic()
#   estimdelta <- 
#     estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
#                          "int", "tel", "HT", "HT", pi, 
#                     estimProbsSelect, sampleMatrix = FALSE)
#   
#   resEvalFull <- estimdelta %>% 
#     estim_MB_by_MCO(Z, phi = phi) %>% 
#     sum()
#   
#   resEvalHT <- estimdelta %>% 
#     estim_MB_by_MCO(Z, phi = phi, weights = estimWeights, mask = maskInt) %>% 
#     sum()
# 
#   # toc() %>% print()
#  
#   
#   results <- results %>% 
#     add_row(parameter = "HT", trueParameter = TRUE,
#             probSelect = "estimation", invMatrix = "true", 
#             calculTotal = c("full", "partial"), 
#             estTotPhiBias = c(resEvalFull, resEvalHT))
#  
#   # Full HT estimation, with sample matrix (Z_S^TZ_S)^-1 and
#   # unknown probabilities
#   # tic()
#   estimdelta <- 
#     estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
#                          "int", "tel", "HT", "HT", pi, 
#                     estimProbsSelect, sampleMatrix = TRUE) 
#   
#   
#   resEvalFull <- estimdelta %>% 
#     estim_MB_by_MCO(Z, phi = phi) %>% 
#     sum()
#   
#   resEvalHT <- estimdelta %>% 
#     estim_MB_by_MCO(Z, phi = phi, weights = estimWeights, mask = maskInt) %>% 
#     sum()
# 
#   # toc() %>% print()
#   
#   results <- results %>% 
#     add_row(parameter = "HT", trueParameter = TRUE,
#             probSelect = "estimation", invMatrix = "sample", 
#             calculTotal = c("full", "partial"), 
#             estTotPhiBias = c(resEvalFull, resEvalHT))
#   
#   
#   
#   estTotalPhiYintHTTrueMP <- 
#     phi[maskInt] * 
#     trueWeights[maskInt] * 
#     Yint[maskInt]
#   
#   estTotalPhiYintHTTrueMP <- sum(estTotalPhiYintHTTrueMP)
#   
#   estTotalPhiYtelHTTrueMP <- 
#     (1.0 - phi[maskTel]) * 
#     trueWeights[maskTel] * 
#     Ytel[maskTel]
#   
#   estTotalPhiYtelHTTrueMP <- sum(estTotalPhiYtelHTTrueMP)
# 
#   estTotalPhiYintHTEstMP <-
#     phi[maskInt] *
#     estimWeights[maskInt] *
#     Yint[maskInt]
# 
#   estTotalPhiYintHTEstMP <- sum(estTotalPhiYintHTEstMP)
# 
#   estTotalPhiYtelHTEstmMP <-
#     (1.0 - phi[maskTel]) *
#     estimWeights[maskTel] *
#     Ytel[maskTel]
# 
#   estTotalPhiYtelHTEstmMP <- sum(estTotalPhiYtelHTEstmMP)
#   
#   # Value estimated only on telephone answers, with estimated selection probabilities
#   benchmark <- sum(estimWeights[maskTel] * Ytel[maskTel])
#   
#   results <- results %>% 
#     add_column(.before = 1L, trueTotalYtel = trueTotalYtel) %>% 
#     add_column(.after = "trueTotalYtel", expectedTotalYtel = expectedTotalYtel) %>% 
#     add_column(.before = "estTotPhiBias", truePhiBias = trueTotalBias) %>% 
#     add_column(.after = "truePhiBias", expectedPhiBias = expectedPhiBias) %>% 
#     add_column(.after = "expectedPhiBias", estTotalPhiYintTrueMP = estTotalPhiYintHTTrueMP) %>% 
#     add_column(.after = "estTotalPhiYintTrueMP", estTotalPhiYintEstMP = estTotalPhiYintHTEstMP) %>% 
#     add_column(.after = "estTotalPhiYintEstMP", estTotalPhiYtelTrueMP = estTotalPhiYtelHTTrueMP) %>% 
#     add_column(.after = "estTotalPhiYtelTrueMP", estTotalPhiYtelEstMP = estTotalPhiYtelHTEstmMP) %>% 
#     mutate(.after = "estTotalPhiYtelEstMP",
#            estTotalYtelTrueMP = estTotalPhiYintTrueMP + estTotalPhiYtelTrueMP - estTotPhiBias) %>% 
#     mutate(.after = "estTotalYtelTrueMP", 
#            estTotalYtelEstMP = estTotalPhiYintEstMP + 
#              estTotalPhiYtelEstMP -
#              estTotPhiBias) %>% 
#     add_column(.after = "estTotalYtelEstMP", benchmark = benchmark) %>% 
#     add_column(.after = "benchmark", sampling = sampling) %>% 
#     add_column(.after = "sampling", YtelLaw = factor(YtelLaw)) %>% 
#     add_column(.after = "YtelLaw", YintLaw = factor(YintLaw)) %>% 
#     add_column(.after = "YintLaw",
#                MBtype = factor(ifelse(constBias, "constant", "variable"))) %>% 
#     add_column(.after = "MBtype", phi = factor(phiType))
#   
#   results
# }
```

-   `trueTotalYtel`: $t_{tel} =\sum_{k \in U} y_{2k}$ for this iteration
-   `expectedTotalYtel` : $\mathbb{E}[t_{tel}]=\mathbb{E} [\sum_{k \in U} y_{2k}]$
-   `estTotPhiBias` : $t_{\phi \hat{\Delta y}}$
-   `truePhiBias` : $t_{\phi\Delta y}=\sum_{k\in U} \phi_k \Delta y_k$
-   `expectedPhiBias` : $\mathbb{E}[t_{\phi\Delta y}]$
-   `estTotalPhiYintTrueMP` : $\hat{t}_{p,\phi y_1} = \sum_{k \in S_r}\frac{\phi_k y_{1k}}{\pi_k p_{1k}}$
-   `estTotalPhiYintEstMP` : $\hat{t}_{\hat{p},\phi y_1} = \sum_{k \in S_r}\frac{\phi_k y_{1k}}{\pi_k \hat{p}_{1k}}$
-   `estTotalPhiYintEstMP` : $\hat{t}_{\hat{p},\phi y_1} + \hat{t}_{\hat{p},\phi y_2} - t_{\phi \hat{\Delta y}}$
-   `benchmark` : $\sum_{k \in S_{mr}} \frac{y_{2k}}{\pi_k(1-p_{1k})p_{2k}}$
-   `calculTotal` : `full` if we calculate $\hat{t}_{\phi \hat{\Delta y}}$ (imputation on the entire population), `partial` if it is $t_{\phi \hat{\Delta y}}$ (on $S_{r\bullet}$)


## Measure bias evaluation

Evaluation of $K$ experiments

```{r}
K <- 5000L
```

```{r}
#| echo: false

set.seed(200L)

results <- NULL
nbResults <- 0L

parameters <- expand_grid(constBias = c(TRUE, FALSE), 
                          sampling = "SRS",#c("SRS", "STSRS"),
                          YtelLaw = c("gaussian", "exponential"),
                          YintLaw = c("gaussian", "exponential"),
                          phi = c("eq", "var")) #c("eq", "var", "bestProb"))


for (i in seq_len(nrow(parameters)))
{
  tic()
  expParams <- parameters[i, ]
  #print(expParams)

  if (expParams$constBias)
  {
    betaIntTemp <- betaTel
    betaIntTemp[1L] <- betaInt[1L]
  }
  else
    betaIntTemp <- betaInt
  
  expResults <- simulationUncounf(N, K = K,
                                  Z = Z, fixZ = TRUE,
                                  sampling = expParams$sampling,
                                  alphaInt = alphaInt,
                                  alphaTel = alphaTel,
                                  betaInt = betaIntTemp,
                                  betaTel = betaTel,
                                  YtelLaw = expParams$YtelLaw,
                                  YintLaw = expParams$YintLaw,
                                  phi = expParams$phi)
  
  # expResults <- lapply(seq_len(K), simulation1, 
  #                      sampling = expParams$sampling,
  #                      constBias = expParams$constBias,
  #                      YtelLaw = expParams$YtelLaw,
  #                      YintLaw = expParams$YintLaw,
  #                      phi = expParams$phi,
  #                      addFalseParameters = FALSE)
  
  #expResults <- do.call("rbind", expResults)

  if (i == 1L)
    expNbResults <- nrow(expResults)
  
  nbresults <- nbResults + expNbResults
  expResults <- expResults %>% 
    add_column(.before = 1L, 
               experiment = factor(rep(nbResults + seq_len(K), 
                                       each = expNbResults / K)))
  
  results <- rbind(results, expResults)
  
  t <- toc(quiet = TRUE)
  
  glue("{unname(t$toc - t$tic)} ({i} / {nrow(parameters)})") %>% print()
}


results$parameter <- as.factor(results$parameter)
results$probSelect <- as.factor(results$probSelect)
results$invMatrix <- as.factor(results$invMatrix)
results$calculTotal <- as.factor(results$calculTotal)

results <- results %>% 
  mutate(.after = "estTotPhiBias", diffPhiBias = estTotPhiBias - truePhiBias) %>% 
  mutate(.after = "estTotalPhiYtelEstMP", 
         diffTotalYtelEstMP = estTotalYtelEstMP - trueTotalYtel) %>% 
  mutate(.after = "estTotalPhiYtelTrueMP",
         diffTotalYtelTrueMP = estTotalYtelTrueMP - trueTotalYtel) %>% 
  mutate(.after = diffTotalYtelTrueMP, diffBenchmark = benchmark - trueTotalYtel)
```

## Ex : Gaussian constant measure bias

Results of each parameter for the case of SRS with **constant** measure bias and Gaussian laws

### Measure bias total

$$\text{reldiffMean} = \frac{1}{K}\sum_{k=1}^K \frac{\hat{t}_{\phi\Delta y,k}-t_{\phi\Delta y,k}}{\mathbb{E}[t_{\phi\Delta y}]}$$

$$\text{relRMSE} = \frac{\sqrt{\frac{1}{K}\sum_{k=1}^K (\hat{t}_{\phi\Delta y,k}-t_{\phi\Delta y,k})^2}}{|\mathbb{E}[t_{\phi\Delta y}]|}$$

```{r}
results %>% 
  filter(YtelLaw == "gaussian", YintLaw == "gaussian", 
         sampling == "SRS", MBtype == "constant",
         probSelect != "true") %>% 
  select(-sampling, -MBtype) %>% 
  group_by(phi, parameter, probSelect, invMatrix, calculTotal) %>% 
  summarise(reldiffMean = round(mean(diffPhiBias / abs(expectedPhiBias)), 4L), 
            relRMSE = round(sqrt(mean(diffPhiBias^2L / expectedPhiBias^2L)), 4L)) %>% 
  ungroup() %>% 
  arrange(relRMSE)
```

### telephone total estimation

```{r}
results %>% 
  filter(YtelLaw == "gaussian", YintLaw == "gaussian", 
         sampling == "SRS", MBtype == "constant",
         probSelect != "true") %>% 
  select(-sampling, -MBtype) %>% 
  group_by(phi, parameter, probSelect, invMatrix, calculTotal) %>% 
  summarise(#reldiffTotalTrueMean = round(mean(diffTotalYtelTrueMP / abs(expectedTotalYtel)) , 4L), 
            reldiffTotalEstMean = round(mean(diffTotalYtelEstMP / abs(expectedTotalYtel)), 4L),
            relDiffBenchmarkMean = round(mean(diffBenchmark / abs(expectedTotalYtel)), 4L),
            #relRMSETrue = round(sqrt(mean(diffTotalYtelTrueMP^2L / expectedTotalYtel^2L)), 4L),
            relRMSEEst = round(sqrt(mean(diffTotalYtelEstMP^2L / expectedTotalYtel^2L)), 4L),
            relRMSEBenchmark = round(sqrt(mean(diffBenchmark^2L / expectedTotalYtel^2L)), 4L),
            relSdTrueWeightsBenchmark = mean(sdTrueWeightsBenchmark / abs(expectedTotalYtel))) %>% 
  ungroup() %>% 
  arrange(relRMSEEst)
```

## Ex : Gaussian variable measure bias

Results of each parameter for the case of SRS with **variable** measure bias and Gaussian laws

```{r}
temp <- results %>% 
  filter(YtelLaw == "gaussian", YintLaw == "gaussian", 
         sampling == "SRS", MBtype == "variable",
         probSelect != "true") %>% 
  select(-sampling, -MBtype) %>% 
  group_by(phi, parameter, probSelect, invMatrix, calculTotal) %>% 
  summarise(#reldiffTotalTrueMean = round(mean(diffTotalYtelTrueMP / abs(expectedTotalYtel)) , 4L), 
            reldiffTotalEstMean = round(mean(diffTotalYtelEstMP / abs(expectedTotalYtel)) , 4L),
            relDiffBenchmarkMean = round(mean(diffBenchmark / abs(expectedTotalYtel)), 4L),
            #relRMSETrue = round(sqrt(mean(diffTotalYtelTrueMP^2L / expectedTotalYtel^2L)), 4L),
            relRMSEEst = round(sqrt(mean(diffTotalYtelEstMP^2L / expectedTotalYtel^2L)), 4L),
            relRMSEBenchmark = round(sqrt(mean(diffBenchmark^2L / expectedTotalYtel^2L)), 4L),
            relSdBenchmark = mean(sdBenchmark / abs(expectedTotalYtel))) %>% 
  ungroup() %>% 
  arrange(relRMSEEst)

temp
```

It is better to have $\phi_k \equiv \phi$ compared to $\phi_k = \frac{k}{N}$. Summing the bias on exclusively $S_{r\bullet}$ seems to be effective

```{r}
temp %>%
  mutate(ratioRMSE = relRMSEEst / relRMSEBenchmark) %>% 
  ggplot() + geom_histogram(aes(x = ratioRMSE)) +
  ggtitle("Ratio RMSE parameter compared to RMSE benchmark")
```

Here are the parameters that offer a better RMSE than the benchmark:
```{r}
temp %>% 
  filter(relRMSEEst <= relRMSEBenchmark) %>% 
  arrange(relRMSEEst)
```

And the parameters that offer the worse RMSE compared to the benchmark:

```{r}
temp %>% 
  slice_max(relRMSEEst, n = 5L)
```


## More general cases

Optimal RMSE for each condition:

```{r}
temp <- results %>% 
  filter(trueParameter, MBtype == "variable") %>% 
  group_by(YintLaw, YtelLaw, phi, sampling, parameter, probSelect, invMatrix, calculTotal) %>% 
  summarise(#reldiffTotalTrueMean = round(mean(diffTotalYtelTrueMP / abs(expectedTotalYtel)) , 4L), 
            reldiffTotalEstMean = round(mean(diffTotalYtelEstMP / abs(expectedTotalYtel)) , 4L),
            relDiffBenchmarkMean = round(mean(diffBenchmark / abs(expectedTotalYtel)), 4L),
            #relRMSETrue = round(sqrt(mean(diffTotalYtelTrueMP^2L / expectedTotalYtel^2L)), 4L),
            relRMSEEst = round(sqrt(mean(diffTotalYtelEstMP^2L / expectedTotalYtel^2L)), 4L),
            relRMSEBenchmark = round(sqrt(mean(diffBenchmark^2L / expectedTotalYtel^2L)), 4L)) %>% 
  ungroup() 

temp %>% 
  group_by(YintLaw, YtelLaw, sampling) %>% 
  slice_min(relRMSEEst)
```

Here are the parameters that offer a better RMSE than the benchmark:
```{r}
temp %>% 
  filter(relRMSEEst <= relRMSEBenchmark) %>% 
  group_by(YintLaw, YtelLaw)
```
