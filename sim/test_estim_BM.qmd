```{r}
library(dplyr)
library(tidyr)
library(glue)
library(tibble)
library(parallel)
library(tictoc)
library(ggplot2)
```

# Linear models on both modes

## Building constants

```{r}
set.seed(145L)
```

```{r}
N <- 1000L
phi <- rep(0.5, N)
```

Creating independent covariates

```{r}
p <- 1L

sex <- sample(c(0L, 1L), replace = TRUE, size = N, prob = c(0.5, 0.5))
age <- rnorm(n = N, mean = sex * 41.1 + (1L - sex) * 43.9, sd = 10.0)
age[age < 0.0] <- 0.0

Z <- data.frame(const = 1.0, 
                age = age, 
                sex = sex)

rm(age)
sex <- factor(sex)
levels(sex) <- c("Woman", "Man")
```

```{r}
summary(Z)
```
```{r}
data <- Z[, c("sex", "age")]
data$sex <- sex
ggplot(data) + geom_density(aes(x = age, colour = sex))
rm(data)
```

```{r}
Z <- as.matrix(Z)
```

Creating parameters for two modes : "int" and "tel"

```{r}
betaInt <- c(4.5, 1.5, 8.0)
betaTel <- c(3.5, -1.0, 16.0)
# betaInt <- rnorm(n = p + 1L, mean = 1.0)
# betaTel <- rnorm(n = p + 1L, mean = 2.0)
```

We simulate a mode selection MAR (Missing At Random) under a logistic model, with $Z$ as variables:

```{r}
# With MAR

expit <- function(x) 1.0 / (1.0 + exp(-x))
# alphaInt <- rnorm(n = p + 1L, mean = 0.0, sd = .5)
alphaInt <- c(0.7, -0.01, -0.5)
#pInt <- runif(N)
pInt <- expit(Z %*% alphaInt) %>% as.vector()

# alphaTel <- rnorm(n = p + 1L, mean = 0.0, sd = .5)
alphaTel <- c(0.3, 0.01, -0.5)
#pTel <- runif(N)
pTel <- expit(Z %*% alphaTel) %>% as.vector()
```



Here are some details about the $p_{int}$ and $p_{tel}$:

```{r}
data.frame(mode = factor(rep(c("int", "tel"), each = N)), 
           prob = c(pInt, pTel)) %>% 
  ggplot() + geom_density(aes(x = prob, color = mode))
```
```{r}
pInt[sex == "Man"] %>% summary()
pInt[sex == "Woman"] %>% summary()
```

```{r}
cat("internet probabilities:\n")
summary(pInt) %>% print()
cat("telephone probabilities:\n")
summary(pTel) %>% print()
```
## Simulation functions
```{r}
gen_choice_bimode <- function(I, p1, p2, mode1 = "int", mode2 = "tel")
{
  N <- length(p1)
  
  R1 <- runif(N) <= p1
  R2 <- runif(N) <= p2
  
  modes <- rep("nr", N)
  modes[R1] <- mode1
  
  modes[!R1 & R2] <- mode2
  
  modes[!I] <- "nr"
  
  modes
}
```

```{r}
simulation1 <- function(constBias = FALSE,
                        sampling = "SRS",
                        YtelLaw = "gaussian", 
                        deltaLaw = "gaussian", ...)
{
  
  # Handling sampling
 
  n <- ceiling(N / 4L)
  
  
  if (sampling == "SRS")
  {
    selectedSample <- sample(seq_len(N), size = n, replace = FALSE)
    pi <- rep(n / N, N)
    I <- rep(FALSE, N)
    I[selectedSample] <- TRUE
    rm(selectedSample)
  }
  
  else if (sampling == "STSRS")
  {
    nbMen <- sum(sex == "Man")
    selectedSampleMen <- sample(which(sex == "Man"),
                                size = ceiling(2L * nbMen / 3L),
                                replace = FALSE)

    nbWomen <- sum(sex == "Woman")
    selectedSampleWomen <- sample(which(sex == "Woman"),
                                  size = ceiling(nbWomen / 3L),
                                  replace = FALSE)
    I <- rep(FALSE, N)
    I[selectedSampleMen] <- TRUE
    I[selectedSampleWomen] <- TRUE
    rm(selectedSampleMen)
    rm(selectedSampleWomen)
    pi <- rep(1.0 / 3.0, N)
    pi[sex == "Man"] <- 2.0 / 3.0
  }
  
  # Mode selection simulation
  modes <- gen_choice_bimode(I, pInt, pTel)
  trueProbsSelect <- rep(NA_real_, N)
  trueProbsSelect[modes == "int"] <- pInt[modes == "int"]
  trueProbsSelect[modes == "tel"] <- ((1.0 - pInt) * pTel)[modes == "tel"]

  # Affecting values to Y_int and Y_tel
  if (YtelLaw == "gaussian")
    Ytel <- Z %*% betaTel + rnorm(n = N, sd = 25.0)
  else if (YtelLaw == "exponential")
    Ytel <- rexp(n = N, rate = abs(Z %*% betaTel)^-1L)
  
  #Yint <- Z %*% betaInt + rnorm(n = N, sd = 25.0)
  
  if (deltaLaw == "gaussian")
  {
    # Case when the measure bias is constant, up to a white noise
    if (constBias)
      deltas <- (betaInt[1L] - betaTel[1L]) + rnorm(N, 0.0, 25.0)
    
    # Case when the measure bias is dependant of the covariates
    else
      ##
      deltas <- Z %*% (betaInt - betaTel) + rnorm(N, 0.0, 25.0)
  }
  else if (deltaLaw == "exponential")
  {
    if (constBias)
      deltas <- rexp(n = N, rate = abs(betaInt[1L] - betaTel[1L])^-1L)
    
    else
      deltas <- rexp(n = N, rate = abs(Z %*% (betaInt - betaTel))^-1L)
  }
  else
    deltas <- seq_len(N)
  
  Yint <- Ytel + deltas

  # Evaluating the measure bias total (random value)
  totalBias <- sum(phi * deltas)
  
  if (constBias)
    expectedBias <- sum(phi) * (betaInt[1L] - betaTel[1L])
  else
    expectedBias <- t(phi) %*% Z %*% (betaInt - betaTel)
  
  
  # Creating the observed outcome vector
  Yobs <- rep(NA_real_, N)
  Yobs[modes == "int"] <- Yint[modes == "int"]
  Yobs[modes == "tel"] <- Ytel[modes == "tel"]
  
  sample <- MMSample$new(Z = Z, pi = pi, I = I, 
                         modes = modes, Yobs = Yobs, phi = phi)
  
  results <- data.frame(trueBias = numeric(), 
                        estimator = character(),
                        trueEstimator = logical(),
                        probSelect = character(),
                        invMatrix = character(),
                        estBias = numeric())
  
  # Full HT estimation, with full population matrix (Z^tZ)^-1 and
  # known probabilities
  # tic()
  resEval <- 
    estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                           "int", "tel", "HT", "HT", pi, 
                    trueProbsSelect, sampleMatrix = FALSE) %>% 
    estim_MB_by_MCO(Z, phi = phi) %>% 
    sum()
  # toc() %>% print()
  
  results <- results %>% 
    add_row(trueBias = totalBias, estimator = "HT", trueEstimator = FALSE,
            probSelect = "true", invMatrix = "true", estBias = resEval)

  # Full HT estimation, with sample matrix (Z_S^TZ_S)^-1 and
  # known probabilities
  # tic()
  resEval <- 
    estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                           "int", "tel", "HT", "HT", pi, 
                    trueProbsSelect, sampleMatrix = TRUE) %>% 
    estim_MB_by_MCO(Z, phi = phi) %>% 
    sum()
  # toc() %>% print()
  
  results <- results %>% 
    add_row(trueBias = totalBias, estimator = "HT", trueEstimator = FALSE,
            probSelect = "true", invMatrix = "sample", estBias = resEval)
  
  
  # G-COMP estimation, <=> double MCO estimation
  # tic()
  resEval <- 
    estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                    "int", "tel", "MCO", "MCO", pi, NULL) %>% 
    estim_MB_by_MCO(Z, phi = phi) %>% 
    sum()
  # toc() %>% print()
  
  
  results <- results %>% 
    add_row(trueBias = totalBias, estimator = "G-COMP", trueEstimator = TRUE,
            probSelect = "null", 
            invMatrix = "null", estBias = resEval)
  
  
  # Estimation on a unique MCO for Y1 and Y2, with beta X and only a constant
  # delta for the estimation of the measure bias
  deltaEval <- estim_delta_MCO_unique_model_const(Z, Yobs, modes, "int", "tel")
  resEval <- sum(phi * deltaEval)
  
  results <- results %>% 
    add_row(trueBias = totalBias, estimator = "MCO_unique", trueEstimator = TRUE,
            probSelect = "null", 
            invMatrix = "null", estBias = resEval)
  
  # Estimation of mode selection probabilities
  tempProbsSelect <- 
    estim_response_prob_sequential(I, Z, modes, c("int", "tel"))$unconditional
  

    # Full HT estimation, with full population matrix (Z^tZ)^-1 and
  # unknown probabilities
  # tic()
  resEval <- 
    estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                         "int", "tel", "HT", "HT", pi, 
                    tempProbsSelect, sampleMatrix = FALSE) %>% 
  estim_MB_by_MCO(Z, phi = phi) %>% 
  sum()
  # toc() %>% print()
 
  
  results <- results %>% 
    add_row(trueBias = totalBias, estimator = "HT", trueEstimator = TRUE,
            probSelect = "estimation", invMatrix = "true", estBias = resEval)
 
  # Full HT estimation, with sample matrix (Z_S^TZ_S)^-1 and
  # unknown probabilities
  # tic()
  resEval <- 
    estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                         "int", "tel", "HT", "HT", pi, 
                    tempProbsSelect, sampleMatrix = TRUE) %>% 
  estim_MB_by_MCO(Z, phi = phi) %>% 
  sum()
  # toc() %>% print()
  
  results <- results %>% 
    add_row(trueBias = totalBias, estimator = "HT", trueEstimator = TRUE,
            probSelect = "estimation", invMatrix = "sample", estBias = resEval)
  
  results <- results %>% 
    add_column(.before = 1L, expectedBias = expectedBias) %>% 
    add_column(.before = 2L, YtelLaw = factor(YtelLaw)) %>% 
    add_column(.before = 3L, deltaLaw = factor(deltaLaw)) %>% 
    add_column(.before = 4L, BMtype = factor(ifelse(constBias, "constant", "variable")))
  
  results
}
```

```{r}
#cluster <- makeCluster(detectCores() - 1L)
```

## Constant measure bias

```{r}
K <- 1000L
```


```{r}
set.seed(200L)

results <- NULL
nbResults <- 0L

parameters <- expand_grid(constBias = c(TRUE, FALSE), 
                          sampling = c("SRS", "STSRS"),
                          YtelLaw = c("gaussian", "exponential"),
                          deltaLaw = c("gaussian", "exponential"))

tic()
for (i in seq_len(nrow(parameters)))
{
  expParams <- parameters[i, ]
  #print(expParams)

  expResults <- lapply(seq_len(K), simulation1, 
                       sampling = expParams$sampling,
                       constBias = expParams$constBias,
                       YtelLaw = expParams$YtelLaw,
                       deltaLaw = expParams$deltaLaw)
  
  expResults <- do.call("rbind", expResults)
  
  
  if (i == 1L)
    expNbResults <- nrow(expResults)
  
  nbresults <- nbResults + expNbResults
  expResults <- expResults %>% 
    add_column(.before = 1L, 
               experiment = factor(rep(nbResults + seq_len(K), 
                                       each = expNbResults / K)))
  
  results <- rbind(results, expResults)
}
toc()
results$estimator <- as.factor(results$estimator)
results$probSelect <- as.factor(results$probSelect)
results$invMatrix <- as.factor(results$invMatrix)

# expBias <- sum(phi) * (betaInt[1L] - betaTel[1L])
# expBias
# 
# constBiases <- do.call("rbind", constBiases)
# constBiases <- constBiases %>% 
#   add_column(.before = 1L, 
#              experiment = factor(rep(seq_len(K), 
#                                      each = nrow(constBiases) / K))) %>% 
#   add_column(.before = "trueBias", expectedBias = expBias)
```

```{r}
results %>% 
  #filter(BMtype == "constant") %>% 
  #mutate(probSelect = ifelse(is.na(probSelect), "null", probSelect)) %>% 
  #mutate(invMatrix = ifelse(is.na(invMatrix), "null", invMatrix)) %>% 
  mutate(diff = estBias - trueBias) %>% 
  group_by(BMtype, YtelLaw, deltaLaw, estimator, probSelect, invMatrix) %>% 
  summarise(reldiffMean = round(mean(diff / abs(expectedBias)) , 4L), 
            relRMSE = round(sqrt(mean(diff^2L / expectedBias^2L)), 4L)) %>% 
  ungroup() %>% 
  group_by(BMtype, YtelLaw, deltaLaw) %>% 
  # arrange(relRMSE) %>% 
  slice_min(relRMSE)
```

```{r}
results %>% 
  filter(probSelect != "true") %>% 
  #filter(BMtype == "constant") %>% 
  #mutate(probSelect = ifelse(is.na(probSelect), "null", probSelect)) %>% 
  #mutate(invMatrix = ifelse(is.na(invMatrix), "null", invMatrix)) %>% 
  mutate(diff = estBias - trueBias) %>% 
  group_by(BMtype, YtelLaw, deltaLaw, estimator, probSelect, invMatrix) %>% 
  summarise(reldiffMean = round(mean(diff / abs(expectedBias)) , 4L), 
            relRMSE = round(sqrt(mean(diff^2L / expectedBias^2L)), 4L)) %>% 
  ungroup() %>% 
  group_by(BMtype, YtelLaw, deltaLaw) %>% 
  # arrange(relRMSE) %>% 
  slice_min(relRMSE)
```
