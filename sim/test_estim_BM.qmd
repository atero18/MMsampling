```{r}
library(dplyr)
library(glue)
```

# Linear models on both modes

```{r}
set.seed(145L)
```

```{r}
N <- 10000L

n <- ceiling(N) # SRS parameter
```



Creating independent covariates

```{r}
p <- 3L

Z <- rnorm(n = N * p) %>% matrix(nrow = N, ncol = p)
```

Creating parameters for two modes : "int" and "tel"

```{r}
betaInt <- rnorm(n = p, mean = 1.0)
betaTel <- rnorm(n = p, mean = 2.0)
```



Simulating a mode selection MAR (Missing At Random) - Creation of the parameters

```{r}
# With MAR

alphaInt <- rnorm(n = p, mean = 0.0, sd = .5)
pInt <- 1.0 / (1.0 + exp(-Z %*% alphaInt)) %>% as.vector()
alphaTel <- rnorm(n = p, mean = 0.0, sd = .5)
pTel <- 1.0 / (1.0 + exp(-Z %*% alphaTel)) %>% as.vector()
```


```{r}
set.seed(150L)
```

```{r}
test <- function()
{
  selectedSample <- sample(seq_len(N), size = n, replace = FALSE)
  pi <- rep(n / N, N)
  I <- rep(FALSE, N)
  I[selectedSample] <- TRUE
  rm(selectedSample)
  
  
  Rint <- runif(N) <= pInt
  Rtel <- runif(N) <= pTel
  
  modes <- rep("nr", N)
  modes[Rint] <- "int"
  
  modes[!Rint & Rtel] <- "tel"
  
  modes[!I] <- "nr"
  nbInt <- sum(modes == "int")
  nbTel <- sum(modes == "tel")
  
  
  probsSelect <- rep(NA_real_, N)
  probsSelect[modes == "int"] <- pInt[modes == "int"]
  probsSelect[modes == "tel"] <- ((1 - pInt) * pTel)[modes == "tel"]
  
  Yint <- Z %*% betaInt + rnorm(n = N)
  Ytel <- Z %*% betaTel + rnorm(n = N)
  
  totalBias <- sum(phi * (Yint - Ytel))
  
  
  Yobs <- rep(NA_real_, N)
  Yobs[modes == "int"] <- Yint[modes == "int"]
  Yobs[modes == "tel"] <- Ytel[modes == "tel"]
  
  empTotBiasHT <- estim_delta_MCO(Z, Yobs, modes, "int", "tel", "HT", "HT", 
                         pi = pi, probsSelect = probsSelect) %>% 
    estim_MB_by_MCO(Z, phi = phi) %>% sum()
  
  empTotBiasGCOMP <- estim_delta_MCO(Z, Yobs, modes, "int", "tel", "MCO", "MCO", 
                         pi = pi, probsSelect = probsSelect) %>% 
    estim_MB_by_MCO(Z, phi = phi) %>% sum()
  
  c(trueTot = totalBias, HT = empTotBiasHT - totalBias, GCOMP = empTotBiasGCOMP- totalBias)

}
```

```{r}
K <- 200L
res <- matrix(nrow = K, ncol = 3L)

for (k in seq_len(K))
  res[k, ] <- test()

apply(res, 2L, mean)
```

Selecting the units in the sample (Simple Random Sampling):

```{r}
selectedSample <- sample(seq_len(N), size = n, replace = FALSE)
pi <- rep(n / N, N)
I <- rep(FALSE, N)
I[selectedSample] <- TRUE
rm(selectedSample)
```


```{r}

Rint <- runif(N) <= pInt
Rtel <- runif(N) <= pTel

modes <- rep("nr", N)
modes[Rint] <- "int"

modes[!Rint & Rtel] <- "tel"

modes[!I] <- "nr"
nbInt <- sum(modes == "int")
nbTel <- sum(modes == "tel")

glue("Number of respondants by internet / telephone: {nbInt} / {nbTel}")
```
Calculating the probability of selecting the associated mode (unconditionally)

```{r}
probsSelect <- rep(NA_real_, N)
probsSelect[modes == "int"] <- pInt[modes == "int"]
probsSelect[modes == "tel"] <- ((1 - pInt) * pTel)[modes == "tel"]
```

Definining the counterfactuals:

```{r}
Yint <- Z %*% betaInt + rnorm(n = N)
Ytel <- Z %*% betaTel + rnorm(n = N)
```

Calculating measure bias (`tel` as reference):

```{r}
biases <- Yint - Ytel
```

Total of the measure bias with $\phi \equiv \frac{1}{2}$ :

```{r}
phi <- rep(0.5, N)
sum(phi * biases)
```

Creating the observed vector:

```{r}
Yobs <- rep(NA_real_, N)
Yobs[modes == "int"] <- Yint[modes == "int"]
Yobs[modes == "tel"] <- Ytel[modes == "tel"]

Yobs[seq_len(15L)]
```

```{r}
res <- estim_delta_MCO(Z, Yobs, modes, "int", "tel", "HT", "HT", 
                       pi = pi, probsSelect = probsSelect) %>% 
  estim_MB_by_MCO(Z, phi = phi)
```

```{r}
sum(res)
```

