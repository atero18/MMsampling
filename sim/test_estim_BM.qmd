```{r}
library(dplyr)
library(tidyr)
library(glue)
library(tibble)
library(parallel)
library(tictoc)
library(ggplot2)
```

```{r}
devtools::load_all()
```

# Linear models on both modes

## Building constants

```{r}
set.seed(145L)
```

```{r}
N <- 1000L
phi <- rep(0.5, N)
```

Creating independent covariates

```{r}
p <- 1L

sex <- sample(c(0L, 1L), replace = TRUE, size = N, prob = c(0.5, 0.5))
age <- rnorm(n = N, mean = sex * 41.1 + (1L - sex) * 43.9, sd = 10.0)
age[age < 0.0] <- 0.0

Z <- data.frame(const = 1.0, 
                age = age, 
                sex = sex)

rm(age)
sex <- factor(sex)
levels(sex) <- c("Woman", "Man")
```

```{r}
summary(Z)
```

```{r}
data <- Z[, c("sex", "age")]
data$sex <- sex
ggplot(data) + 
  geom_density(aes(x = age, colour = sex)) +
  ggtitle("Age ~ sex")
rm(data)
```

```{r}
Z <- as.matrix(Z)
```

Creating parameters for two modes : "int" and "tel"

```{r}
betaInt <- c(4.5, 1.5, 8.0)
betaTel <- c(3.5, -1.0, 16.0)
```

We simulate a mode selection MAR (Missing At Random) under a logistic model, with $Z$ as variable:

```{r}
# With MAR

expit <- function(x) 1.0 / (1.0 + exp(-x))

alphaInt <- c(0.7, -0.02, -0.5)
pInt <- expit(Z %*% alphaInt) %>% as.vector()

alphaTel <- c(0.3, 0.02, -0.5)
pTel <- expit(Z %*% alphaTel) %>% as.vector()
```

Here are some details about the $p_{int}$ and $p_{tel}$:

```{r}
data.frame(mode = factor(rep(c("int", "tel"), each = N)), 
           prob = c(pInt, pTel)) %>% 
  ggplot() + 
  geom_density(aes(x = prob, color = mode)) +
  ggtitle("Distribution of p_int and p_tel")
```

```{r}
pInt[sex == "Man"] %>% summary()
pInt[sex == "Woman"] %>% summary()
```

```{r}
cat("internet probabilities:\n")
summary(pInt) %>% print()
cat("telephone probabilities:\n")
summary(pTel) %>% print()
```

## Simulation functions

Randomly affect a mode (or non-response) to each unit

```{r}
gen_choice_bimode <- function(I, p1, p2, mode1 = "int", mode2 = "tel")
{
  N <- length(p1)
  
  R1 <- runif(N) <= p1
  R2 <- runif(N) <= p2
  
  modes <- rep("nr", N)
  modes[R1] <- mode1
  
  modes[!R1 & R2] <- mode2
  
  modes[!I] <- "nr"
  
  modes
}
```

Parameters:

-   the constance of the bias, up to a Gaussian noise (`constBias`)
-   the sampling type (`sampling`)
-   the law of $Y_{tel}$ (`YtelLaw`)
-   the law of $\Delta y$ (`deltaLaw`)

```{r}
#| echo: false

simulation1 <- function(constBias = FALSE,
                        sampling = "SRS",
                        YtelLaw = "gaussian", 
                        deltaLaw = "gaussian",
                        phiType = "eq",
                        ...)
{
  if (phiType == "eq")
    phi <- rep(0.5, N)
  
  else if (phiType == "var")
    phi <- seq_len(N) / N
  
  # Handling sampling
 
  n <- ceiling(N / 4L)
  
  
  if (sampling == "SRS")
  {
    selectedSample <- sample(seq_len(N), size = n, replace = FALSE)
    pi <- rep(n / N, N)
    I <- rep(FALSE, N)
    I[selectedSample] <- TRUE
    rm(selectedSample)
  }
  
  else if (sampling == "STSRS")
  {
    nbMen <- sum(sex == "Man")
    selectedSampleMen <- sample(which(sex == "Man"),
                                size = ceiling(2L * nbMen / 3L),
                                replace = FALSE)

    nbWomen <- sum(sex == "Woman")
    selectedSampleWomen <- sample(which(sex == "Woman"),
                                  size = ceiling(nbWomen / 3L),
                                  replace = FALSE)
    I <- rep(FALSE, N)
    I[selectedSampleMen] <- TRUE
    I[selectedSampleWomen] <- TRUE
    rm(selectedSampleMen)
    rm(selectedSampleWomen)
    pi <- rep(1.0 / 3.0, N)
    pi[sex == "Man"] <- 2.0 / 3.0
  }
  
  # Mode selection simulation
  modes <- gen_choice_bimode(I, pInt, pTel)
  trueProbsSelect <- rep(NA_real_, N)
  trueProbsSelect[modes == "int"] <- pInt[modes == "int"]
  trueProbsSelect[modes == "tel"] <- ((1.0 - pInt) * pTel)[modes == "tel"]

  # Affecting values to Y_int and Y_tel
  if (YtelLaw == "gaussian")
    Ytel <- Z %*% betaTel + rnorm(n = N, sd = 25.0)
  else if (YtelLaw == "exponential")
    Ytel <- rexp(n = N, rate = abs(Z %*% betaTel)^-1L)
  
  #Yint <- Z %*% betaInt + rnorm(n = N, sd = 25.0)
  
  if (deltaLaw == "gaussian")
  {
    # Case when the measure bias is constant, up to a white noise
    if (constBias)
      deltas <- rnorm(N, betaInt[1L] - betaTel[1L], 25.0)
    
    # Case when the measure bias is dependant of the covariates
    else
      deltas <- Z %*% (betaInt - betaTel) + rnorm(N, 0.0, 25.0)
  }
  else if (deltaLaw == "exponential")
  {
    if (constBias)
      deltas <- rexp(n = N, rate = abs(betaInt[1L] - betaTel[1L])^-1L)
    
    else
      deltas <- rexp(n = N, rate = abs(Z %*% (betaInt - betaTel))^-1L)
  }
  else
    deltas <- seq_len(N)
  
  Yint <- Ytel + deltas

  # Evaluating the measure bias total (random value)
  totalBias <- sum(phi * deltas)
  
  if (constBias)
    expectedBias <- sum(phi) * (betaInt[1L] - betaTel[1L])
  else
    expectedBias <- t(phi) %*% Z %*% (betaInt - betaTel)
  
  
  # Creating the observed outcome vector
  Yobs <- rep(NA_real_, N)
  Yobs[modes == "int"] <- Yint[modes == "int"]
  Yobs[modes == "tel"] <- Ytel[modes == "tel"]
  
  sample <- MMSample$new(Z = Z, pi = pi, I = I, 
                         modes = modes, Yobs = Yobs, phi = phi)
  
  results <- data.frame(trueBias = numeric(), 
                        estimator = character(),
                        trueEstimator = logical(),
                        probSelect = character(),
                        invMatrix = character(),
                        estBias = numeric())
  
  # Full HT estimation, with full population matrix (Z^tZ)^-1 and
  # known probabilities
  # tic()
  # resEval <- 
  #   estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
  #                          "int", "tel", "HT", "HT", pi, 
  #                   trueProbsSelect, sampleMatrix = FALSE) %>% 
  #   estim_MB_by_MCO(Z, phi = phi) %>% 
  #   sum()
  # toc() %>% print()
  
  # results <- results %>% 
  #   add_row(trueBias = totalBias, estimator = "HT", trueEstimator = FALSE,
  #           probSelect = "true", invMatrix = "true", estBias = resEval)

  # Full HT estimation, with sample matrix (Z_S^TZ_S)^-1 and
  # known probabilities
  # tic()
  # resEval <- 
  #   estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
  #                          "int", "tel", "HT", "HT", pi, 
  #                   trueProbsSelect, sampleMatrix = TRUE) %>% 
  #   estim_MB_by_MCO(Z, phi = phi) %>% 
  #   sum()
  # toc() %>% print()
  
  # results <- results %>% 
  #   add_row(trueBias = totalBias, estimator = "HT", trueEstimator = FALSE,
  #           probSelect = "true", invMatrix = "sample", estBias = resEval)
  
  
  # G-COMP estimation, <=> double MCO estimation
  # tic()
  resEval <- 
    estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                    "int", "tel", "MCO", "MCO", pi, NULL) %>% 
    estim_MB_by_MCO(Z, phi = phi) %>% 
    sum()
  # toc() %>% print()
  
  
  results <- results %>% 
    add_row(trueBias = totalBias, estimator = "G-COMP", trueEstimator = TRUE,
            probSelect = "null", 
            invMatrix = "null", estBias = resEval)
  
  
  # Estimation on a unique MCO for Y1 and Y2, with beta X and only a constant
  # delta for the estimation of the measure bias
  deltaEval <- estim_delta_MCO_unique_model_const(Z, Yobs, modes, "int", "tel")
  resEval <- sum(phi) * deltaEval
  
  results <- results %>% 
    add_row(trueBias = totalBias, estimator = "MCO_unique", trueEstimator = TRUE,
            probSelect = "null", 
            invMatrix = "null", estBias = resEval)
  
  # Estimation of mode selection probabilities
  tempProbsSelect <- 
    estim_response_prob_sequential(I, Z, modes, c("int", "tel"))$unconditional
  

    # Full HT estimation, with full population matrix (Z^tZ)^-1 and
  # unknown probabilities
  # tic()
  resEval <- 
    estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                         "int", "tel", "HT", "HT", pi, 
                    tempProbsSelect, sampleMatrix = FALSE) %>% 
  estim_MB_by_MCO(Z, phi = phi) %>% 
  sum()
  # toc() %>% print()
 
  
  results <- results %>% 
    add_row(trueBias = totalBias, estimator = "HT", trueEstimator = TRUE,
            probSelect = "estimation", invMatrix = "true", estBias = resEval)
 
  # Full HT estimation, with sample matrix (Z_S^TZ_S)^-1 and
  # unknown probabilities
  # tic()
  resEval <- 
    estim_delta_MCO(sample$Z, sample$Yobs, sample$modes, 
                         "int", "tel", "HT", "HT", pi, 
                    tempProbsSelect, sampleMatrix = TRUE) %>% 
  estim_MB_by_MCO(Z, phi = phi) %>% 
  sum()
  # toc() %>% print()
  
  results <- results %>% 
    add_row(trueBias = totalBias, estimator = "HT", trueEstimator = TRUE,
            probSelect = "estimation", invMatrix = "sample", estBias = resEval)
  
  results <- results %>% 
    add_column(.before = 1L, expectedBias = expectedBias) %>% 
    add_column(.before = 2L, sampling = sampling) %>% 
    add_column(.before = 3L, YtelLaw = factor(YtelLaw)) %>% 
    add_column(.after = "YtelLaw", deltaLaw = factor(deltaLaw)) %>% 
    add_column(.after = "deltaLaw", MBtype = factor(ifelse(constBias, "constant", "variable"))) %>% 
    add_column(.after = "MBtype", phi = factor(phiType))
  
  results
}
```

## Measure bias evaluation

Evaluation of $K$ experiments

```{r}
K <- 1000L
```

```{r}
#| echo: false

set.seed(200L)

results <- NULL
nbResults <- 0L

parameters <- expand_grid(constBias = c(TRUE, FALSE), 
                          sampling = c("SRS", "STSRS"),
                          YtelLaw = c("gaussian", "exponential"),
                          deltaLaw = c("gaussian", "exponential"),
                          phi = c("eq", "var"))

tic()
for (i in seq_len(nrow(parameters)))
{
  expParams <- parameters[i, ]
  #print(expParams)

  expResults <- lapply(seq_len(K), simulation1, 
                       sampling = expParams$sampling,
                       constBias = expParams$constBias,
                       YtelLaw = expParams$YtelLaw,
                       deltaLaw = expParams$deltaLaw,
                       phi = expParams$phi)
  
  expResults <- do.call("rbind", expResults)
  
  
  if (i == 1L)
    expNbResults <- nrow(expResults)
  
  nbresults <- nbResults + expNbResults
  expResults <- expResults %>% 
    add_column(.before = 1L, 
               experiment = factor(rep(nbResults + seq_len(K), 
                                       each = expNbResults / K)))
  
  results <- rbind(results, expResults)
}
toc()

results$estimator <- as.factor(results$estimator)
results$probSelect <- as.factor(results$probSelect)
results$invMatrix <- as.factor(results$invMatrix)
results <- mutate(results, .after = "estBias", diff = estBias - trueBias)
```

## Ex : Gaussian constant measure bias

Results of each estimator for the case of SRS with **constant** measure bias and Gaussian laws

$$\text{reldiffMean} = \frac{1}{K}\sum_{k=1}^K \frac{\hat{t}_{\phi\Delta y,k}-t_{\phi\Delta y,k}}{\mathbb{E}[t_{\phi\Delta y}]}$$

$$\text{relRMSE} = \frac{\sqrt{\frac{1}{K}\sum_{k=1}^K (\hat{t}_{\phi\Delta y,k}-t_{\phi\Delta y,k})^2}}{|\mathbb{E}[t_{\phi\Delta y}]|}$$

```{r}
results %>% 
  filter(YtelLaw == "gaussian", deltaLaw == "gaussian", 
         sampling == "SRS", MBtype == "constant",
         probSelect != "true") %>% 
  select(-sampling, -MBtype) %>% 
  group_by(phi, estimator, probSelect, invMatrix) %>% 
  summarise(reldiffMean = round(mean(diff / abs(expectedBias)) , 4L), 
            relRMSE = round(sqrt(mean(diff^2L / expectedBias^2L)), 4L)) %>% 
  ungroup() %>% 
  arrange(relRMSE)
```

Differences between G-COMP and HT with sample inverse matrix results in that case (with constant phi):

```{r}
results %>% 
  filter(YtelLaw == "gaussian", deltaLaw == "gaussian", 
         sampling == "SRS", MBtype == "constant",
         phi == "eq",  trueEstimator, estimator == "G-COMP" | (estimator == "HT" & invMatrix == "sample")) %>% 
  select(experiment, estimator, invMatrix, diff) %>% 
  head(n = 8L) %>% 
  group_by(experiment)
```

## Ex : Gaussian variable measure bias

Results of each estimator for the case of SRS with **variable** measure bias and Gaussian laws

```{r}
results %>% 
  filter(YtelLaw == "gaussian", deltaLaw == "gaussian", 
         sampling == "SRS", MBtype == "variable",
         phi == "eq", trueEstimator) %>% 
  select(-sampling, -MBtype, -phi) %>% 
  group_by(phi, estimator, probSelect, invMatrix) %>% 
  summarise(reldiffMean = round(mean(diff / abs(expectedBias)) , 4L), 
            relRMSE = round(sqrt(mean(diff^2L / expectedBias^2L)), 4L)) %>% 
  ungroup() %>% 
  arrange(relRMSE)
```

Optimal RMSE for each condition:

```{r}
results %>% 
  filter(probSelect != "true") %>% 
  group_by(MBtype, sampling, YtelLaw, deltaLaw, phi, estimator, probSelect, invMatrix) %>% 
  summarise(reldiffMean = round(mean(diff / abs(expectedBias)) , 4L), 
            relRMSE = round(sqrt(mean(diff^2L / expectedBias^2L)), 4L)) %>% 
  ungroup() %>% 
  group_by(MBtype, YtelLaw, deltaLaw, sampling, phi) %>% 
  slice_min(relRMSE) # %>% 
  # knitr::kable()
```
